<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>SPAプロジェクト：リアルタイム異常検知アプリ（高速版・5秒平均SPAレベル）</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>
    :root{
      --bg:#0b1220; --panel:#121a2a; --ink:#e6eefc; --muted:#a5b4d4; --accent:#6fd3ff; --accent2:#ffb86b; --danger:#ff6b6b; --ok:#20c997; --grid:#1c2740; --grid2:#223050;
    }
    *{box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic UI","Yu Gothic","Meiryo",sans-serif}
    body{margin:0;background:var(--bg);color:var(--ink)}
    .wrap{display:grid;grid-template-columns:1fr 360px;gap:14px;min-height:100vh;padding:14px}
    .card{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);overflow:hidden;border:1px solid #1a2236}
    .head{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #1a2236;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0))}
    .title{font-weight:700;letter-spacing:.2px}
    .canvas-wrap{position:relative;height:420px}
    canvas{display:block;width:100%;height:100%;background:#000000;bottom:8px;left:10px;font-size:12px;color:var(--muted);background:rgba(0,0,0,.3);padding:4px 8px;border-radius:8px;border:1px solid #1a2236}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:6px}
    .pad{padding:12px 14px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    label{font-size:12px;color:var(--muted)}
    input[type="number"],input[type="text"],select{width:100%;background:#0e1626;color:var(--ink);border:1px solid #1a2236;border-radius:10px;padding:8px 10px;outline:none}
    input[type="range"]{width:100%}
    .btn{background:#0e9bdd;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#2b3756}
    .btn.danger{background:#e84e4e}
    .kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
    .kpi .item{background:#0e1626;border:1px solid #1a2236;border-radius:12px;padding:10px}
    .kpi .val{font-size:20px;font-weight:800}
    .badge{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #1a2236;color:var(--muted)}
    .ok{color:var(--ok)} .warn{color:var(--accent2)} .ng{color:var(--danger)}
    .note{font-size:12px;color:var(--muted)}
    .audio-pill{font-size:12px;padding:4px 10px;border-radius:999px;border:1px solid #1a2236;background:#0e1626;color:var(--muted)}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
  
/* --- GPSカードを横一列化 --- */
#gpsPanel .grid {
  display: flex !important;
  flex-wrap: nowrap !important;
  gap: 6px;
  overflow-x: auto;       /* 横スクロール可能にする */
  padding-bottom: 4px;
}
#gpsPanel .col {
  flex: 0 0 auto;         /* 幅を固定（自動で縮まない） */
  min-width: 100px;       /* 各カードの最小幅 */
}
#gpsPanel .col input[type="text"] {
  font-size: 12px;
  padding: 4px 6px;
  border-radius: 6px;
  width: 100%;
}
#gpsPanel .col label {
  font-size: 11px;
  margin-bottom: 2px;
}

</style>
<meta content="#0b1220" name="theme-color"/>
<link href="manifest.webmanifest" rel="manifest"/>

<script>
// ===== CSVファイル名を「場所_観測者_YYYYMMDD_HHMMSS.csv」で自動生成（JST） =====
(function(){
  if (typeof window.makeCsvFilename === 'function') return;
  window.makeCsvFilename = function makeCsvFilename() {
    function jstStamp() {
      const d = new Date();
      const f = n => String(n).padStart(2, '0');
      return (
        d.getFullYear() +
        f(d.getMonth() + 1) +
        f(d.getDate()) + "_" +
        f(d.getHours()) +
        f(d.getMinutes()) +
        f(d.getSeconds())
      );
    }
    function sanitizeName(s){
      return String(s || '')
        .replace(/[\\/:*?"<>|]/g, '-')
        .replace(/\s+/g, '_')
        .slice(0, 40);
    }
    const placeEl = document.getElementById('placeName');
    const obsEl   = document.getElementById('observerName');
    const place = sanitizeName(placeEl && placeEl.value ? placeEl.value : '場所不明');
    const obs   = sanitizeName(obsEl   && obsEl.value   ? obsEl.value   : '観測者不明');
    const stamp = jstStamp();
    return `${place}_${obs}_${stamp}.csv`;
  };
})();
</script>


<script>
function vibrateByA(a, th, scale=1.0){
  if (!('vibrate' in navigator)) return;
  const aEff = Math.max(0, (a - th));
  const dur  = Math.min(300, Math.round((40 + aEff * 80) * scale));
  const reps = Math.min(4, 1 + Math.floor(aEff * 1.5));
  const gap  = 60;
  const pattern = Array.from({length: reps*2-1}, (_,i)=> i%2===0 ? dur : gap);
  navigator.vibrate(pattern);
}
</script>

</head>
<body>
<div class="wrap">
<!-- Left: Strip Monitor -->
<div class="card" id="monitorCard">
<div class="head">
<div class="row">
<div class="title">ストリップモニタ（高速・5秒平均レベル）</div>
<div class="audio-pill" id="audioStatus">音声: 無効（ページをクリック）</div>
</div>
<div class="row">
<button class="btn" id="btnStart">スキャン実行</button>
<button class="btn secondary" id="btnStop">停止</button>
<button class="btn danger" id="btnReset">リセット</button>
</div>
</div>
<div class="canvas-wrap">
<canvas id="scope"></canvas>
<div class="legend">閾値超過: 880Hz / 2σ超過: 1320Hz</div>
</div>
<div class="pad">
<div class="kpi">
<div class="item">
<div class="badge">p値（区間平均）</div>
<div class="val" id="kpiP">—</div>
</div>
<div class="item">
<div class="badge">SPA値（区間平均）</div>
<div class="val" id="kpiSPA">—</div>
</div>
<div class="item">
<div class="badge">SPAレベル（区間平均×2.44）</div>
<div class="val" id="kpiLevel">—</div>
</div>
<div class="item">
<div class="badge">SPAレベル（期間平均A）</div>
<div class="val" id="kpiLevelA">—</div>
<div class="note" style="margin-top:6px">
  〈Aの瞬間最大〉 <b id="kpiLevelAmax">—</b>
</div>
<div class="note">
              集計期間: <input id="inpAvgSecA" min="0.2" step="0.1" style="width:70px;" type="number" value="0.5"/> 秒
              <span style="margin-left:10px;color:#8aa0b5">※ 第2位四捨五入→第1位表示</span>
</div>
</div>
<div class="item">
<div class="badge">SPAレベル（期間平均B）</div>
<div class="val" id="kpiLevelB">—</div><div class="note" style="margin-top:6px">〈Bの瞬間最大〉 <b id="kpiLevelBmax">—</b></div>
<div class="note">
              集計期間: <input id="inpAvgSecB" min="0.5" step="0.5" style="width:70px;" type="number" value="3"/> 秒
              <span style="margin-left:10px;color:#8aa0b5">※ 第2位四捨五入→第1位表示</span>
</div>
</div>
<div class="item">
<div class="badge">SPAレベル（期間平均C）</div>
<div class="val" id="kpiLevelC">—</div>
<div class="note">
              集計期間: <input id="inpAvgSecC" min="0" step="0.5" style="width:70px;" type="number" value="0"/> 秒
<div class="note" style="margin-top:6px">
  〈Cの期間〉 <b id="lblCperiod">—</b> ／ 〈経過〉 <b id="lblElapsed">00:00</b>
</div>
<span style="margin-left:10px;color:#8aa0b5">0 = 全時間（開始からの累積平均）</span>
</div>
</div>
</div>
<div class="note" id="intervalNote">集計間隔: 5.0 秒</div>
<div class="pad" id="gpsPanel" style="margin-top:12px; border-top:1px solid #1a2236; padding-top:12px;">
<div class="title" style="font-size:14px; margin-bottom:6px;">位置情報（GPS）</div>
<div class="row" style="gap:8px; flex-wrap:wrap;">
<button class="btn" id="btnGeoStart">位置取得開始</button>
<button class="btn secondary" id="btnGeoStop">停止</button>
<button class="btn" id="btnGeoCopy">座標コピー</button>
<label style="display:flex;align-items:center;gap:6px"><input checked="" id="chkAttachLoc" type="checkbox"/> 記録に座標を含める</label>
<button class="btn secondary" id="btnExportCSV">イベントCSV</button>
</div>
<div class="grid" style="margin-top:8px">
<div class="col"><label>緯度</label><input id="geoLat" readonly="" type="text" value="—"/></div>
<div class="col"><label>経度</label><input id="geoLon" readonly="" type="text" value="—"/></div>
<div class="col"><label>精度（m）</label><input id="geoAcc" readonly="" type="text" value="—"/></div>
<div class="col"><label>速度（m/s）</label><input id="geoSpd" readonly="" type="text" value="—"/></div>
<div class="col"><label>方位（deg）</label><input id="geoHead" readonly="" type="text" value="—"/></div>
<div class="col"><label>時刻</label><input id="geoTime" readonly="" type="text" value="—"/></div>
</div>
<div class="note" id="geoStatus" style="margin-top:6px">GPS: 未開始（許可が必要）</div>
</div>
<div class="pad" id="placePanel" style="margin-top:12px; border-top:1px solid #1a2236; padding-top:12px;">
<div class="title" style="font-size:14px; margin-bottom:6px;">場所メモ（手打ち）</div>
<div class="grid" style="gap:10px">
<div class="col">
<label>場所名</label>
<input id="placeName" placeholder="例：第3ライン 2番機 入口付近" type="text"/>
</div>
<div class="col">
<label>備考（任意）</label>
<input id="placeMemo" placeholder="例：午前のみ稼働、高温注意 など" type="text"/>
</div>
</div>
<div class="row" style="gap:10px; margin-top:8px">
<div class="col" style="flex:1 1 240px">
<label>観測者</label>
<input id="observerName" placeholder="例：梅本 幹則" type="text"/>
</div>
</div>
<div class="row" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
<button class="btn" id="btnSetPlace">現在の場所にセット</button>
<button class="btn secondary" id="btnClearPlace">クリア</button>
<label style="display:flex;align-items:center;gap:6px"><input checked="" id="chkIncludePlace" type="checkbox"/> 記録に場所名を含める</label>
<button class="btn" id="btnManualLog">今を記録</button>
</div>

</div>
</div>
</div>
<!-- Right: Controls -->
<div class="card">
<div class="head">
<div class="title">コントロール</div>
<span class="note">完全オフライン / 外部CDN不要</span>
</div>
<div class="pad">
<div class="grid">
<div class="col">
<label>ウィンドウ幅 N（点）</label>
<input id="inpN" max="5000" min="100" step="50" type="number" value="1200"/>
</div>
<div class="col">
<label>描画速度（サンプル/秒）</label>
<input id="inpSpeed" max="120" min="5" step="1" type="range" value="120"/>
<div class="note" id="speedLabel">60 sps</div>
</div>
<div class="col">
<label>T（ステップ標準偏差）</label>
<input id="inpSigma" max="10" min="0.1" step="0.1" type="number" value="1.2"/>
</div>
<div class="col">
<label>ドリフト抑制 α（0..1 小さいほど自由）</label>
<input id="inpAlpha" max="0.1" min="0" step="0.002" type="range" value="0.100"/>
  <div class="col">
    <label>ノイズモデル</label>
    <select id="selNoise" class="sel" style="width:100%">
      <option value="ar1">連続（AR1: 前回値＋揺れ）</option>
      <option value="iid" selected>独立（IID: 前回値を使わない）</option>
    </select>
    <div class="note">IIDでは x=σ·ε を毎回サンプル（連続性なし）。</div>
  </div>

<div class="note" id="alphaLabel">α = 0.100</div>
</div>
<div class="col">
<label>閾値 |x| &gt;= </label>
<input id="inpThresh" max="100" min="0.5" step="0.5" type="number" value="6"/>
</div>
<div class="col">
<label>閾値モード</label>
<select id="selThreshMode">
<option selected="" value="abs">絶対値（|x| ≥ 閾値）</option>
<option value="z">Zスコア（|z| ≥ 閾値）</option>
</select>
</div>
<div class="col">
<label>縦軸モード</label>
<select id="selYMode">
<option selected="" value="fixed">固定（±Ymax）</option>
<option value="auto">AUTO</option>
</select>
</div>
<div class="col">
<label>Ymax（固定時）</label>
<input id="inpYmax" max="200" min="2" step="1" type="number" value="15"/>
</div>
<div class="col">
<label>2σ判定の窓幅（点）</label>
<input id="inpZwin" max="2000" min="30" step="10" type="number" value="120"/>
  <div class="col">
    <label>Z基準</label>
    <select id="selZbasis" class="sel" style="width:100%">
      <option value="emp">実測（移動窓）</option>
      <option value="theory">理論（定常分散）</option>
    </select>
    <div class="note">理論=E[x]=0, Var[x]=σ²/(2α−α²)（IIDならσ²）でZを計算。</div>
  </div>

</div>
<div class="col">
<label>ビープ音</label>
<select id="selAudio">
<option selected="" value="on">オン</option>
<option value="off">オフ</option>
</select>
</div>
<div class="col">
<label>SPA方式</label>
<select id="selSpaMode">
<option value="freq">頻度SPA（従来）</option>
<option selected="" value="inst">瞬間Z p（新方式）</option>
<option value="batch">バッチp（窓で1回以上）</option>
        <option value="freq_inv">逆頻度SPA（繰返し強調）</option>
</select>
</div>
<div class="col">
<label>SPA表示ウォームアップ（サンプル）</label>
<input id="inpWarm" max="5000" min="0" step="50" type="number" value="200"/>
</div>
<div class="col">
<label>レベル集計間隔（秒）</label>
<input id="inpIntervalSec" max="30" min="1" step="0.5" type="number" value="1"/>
</div>
<div class="col">
<label>音量スケール</label>
<input id="rngVolScale" max="3.0" min="0.2" step="0.05" type="range" value="1.0"/>
<div><small id="lblVolScale">1.00×</small></div>
</div>
<div class="col">
<label>ピッチ刻み（Hz/レベル）</label>
<input id="rngPitchStep" max="400" min="40" step="5" type="range" value="160"/>
<div><small id="lblPitchStep">160 Hz/level</small></div>
</div>
<div class="col">
<label>最大音量キャップ</label>
<input id="rngVolMax" max="1.0" min="0.1" step="0.01" type="range" value="1.0"/>
<div><small id="lblVolMax">1.00</small></div>
</div>
<div class="col">
<label>プリセット</label>
<div style="display:flex;gap:6px;flex-wrap:wrap">
<button id="btnPresetQuiet" type="button">静音</button>
<button id="btnPresetNormal" type="button">標準</button>
<button id="btnPresetStrong" style="background:#e03131;color:#fff;" type="button">強演出</button>
</div>
<label style="margin-top:6px;display:block;"><input checked="" id="chkStrongFX" type="checkbox"/> 強演出エフェクトを有効化（フラッシュ/バイブ）</label>
</div>
<div class="col" style="margin-top:10px;">
  <label style="font-weight:600; display:block; margin-bottom:6px;">バイブの発火条件（SPA）※初期設定は「Aのみ」</label>
  <label style="display:block; margin:4px 0;">
    <input id="chkVibeBySpa" type="checkbox" checked>
    バイブは「瞬間 / A / B」のSPAレベル条件でのみ作動（2σ/閾値イベントだけでは作動しない）
  </label>
  <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; font-size:13px;">
    <label style="display:flex; align-items:center; gap:6px;"><input id="chkVibeInst" type="checkbox"> 瞬間</label>
    <label style="display:flex; align-items:center; gap:6px;"><input id="chkVibeA" type="checkbox" checked checked> A</label>
    <label style="display:flex; align-items:center; gap:6px;"><input id="chkVibeB" type="checkbox"> B</label>
    <span class="note">※ しきい値は既存の「SPAレベル自動記録（≧）」の数値を流用します</span>
  </div>
</div>
<div class="col" id="vibeThreshBox" style="margin-top:8px;">
  <label style="font-weight:600; display:block; margin-bottom:6px;">バイブ用しきい値</label>
  <label style="display:block; margin:4px 0">
    <input id="chkVibeOwnThresh" type="checkbox">
    しきい値を個別に指定（OFFのときは「SPAレベル自動記録（≧）」の値を流用）
  </label>
  <div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; font-size:13px;">
    <label style="display:flex; align-items:center; gap:6px;">
      Inst ≥ <input id="inpVibeInstThresh" type="number" step="0.1" min="0" max="99" value="2.0" style="width:80px;"/>
    </label>
    <label style="display:flex; align-items:center; gap:6px;">
      A ≥ <input id="inpVibeAThresh" type="number" step="0.1" min="0" max="99" value="2.0" style="width:80px;"/>
    </label>
    <label style="display:flex; align-items:center; gap:6px;">
      B ≥ <input id="inpVibeBThresh" type="number" step="0.1" min="0" max="99" value="2.0" style="width:80px;"/>
    </label>
    <span class="note">単位はいずれも「SPAレベル」。</span>
  </div>
</div>


<div class="col">
<label>波形</label>
<select id="selWave">
<option selected="" value="sine">サイン</option>
<option value="triangle">トライアングル</option>
<option value="sawtooth">のこぎり波</option>
<option value="square">矩形</option>
</select>
</div>
<div class="col">
<label>ディストーション</label>
<input id="rngDist" max="40" min="0" step="1" type="range" value="0"/>
<div><small id="lblDist">0</small></div>
</div>
<div class="col">
<label>フラッシュ・スタイル</label>
<select id="selFlash">
<option selected="" value="red">赤（ラジアル）</option>
<option value="white">白（ストロボ）</option>
<option value="blue">青（ラジアル）</option>
</select>
<label style="margin-top:6px;display:block;"><input checked="" id="chkAutoStrong" type="checkbox"/> 起動時に強演出を自動ON</label>
</div>

<div class="col">
  <label>背景スタイル</label>
  <select id="selBgStyle" style="width:100%">
    <option value="straight" selected>直線グリッド（白）</option>
    <option value="curved">曲線グリッド（白）</option>
    <option value="neon">直線グリッド（ネオン青）</option>
    <option value="dot">直線グリッド（点線・白）</option>
    <option value="radar">レーダー風（放射＋同心円）</option>
    <option value="gradient">直線グリッド（上下グラデ）</option>
  </select>
</div>

<div class="col">
<label>テスト</label>
<button id="btnTestFlash" type="button">フラッシュテスト</button>
<button id="btnTestVibrate" type="button">バイブテスト</button>
</div>
</div>
<!-- ▼（移設）サンプリング速度 / 超え率モード（裏のコントロールに統合） -->
<div class="pad" id="movedControlsBlock" style="border-top:1px solid #1a2236; margin-top:10px; padding-top:12px;">
<div class="col">
<label style="font-weight:600; display:block; margin-bottom:6px;">サンプリング速度（回/秒）</label>
<input id="samplingRate" max="120" min="5" step="5" style="width:100%;" type="range" value="60"/>
<div style="display:flex; justify-content:space-between; font-size:12px; color:#9ab;">
<span>5 Hz</span><span>120 Hz</span>
</div>
<div style="margin-top:4px; font-size:13px;">
      現在: <b><span id="samplingRateLabel">60</span> Hz</b>（<span id="samplingIntervalLabel">16.7</span> ms 間隔）
    </div>
</div>
<div class="col" style="margin-top:12px;">
<div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
<label style="font-weight:600;">超え率モード</label>
<label><input name="freqMode" type="radio" value="cumulative"/> 累積</label>
<label><input checked="" name="freqMode" type="radio" value="window"/> 区間（直近 <input id="freqWindowSec" max="30" min="1" style="width:4em;" type="number" value="1"/> 秒）</label>
<button id="freqResetBtn" style="margin-left:auto; padding:4px 10px;" type="button">区間リセット</button>
</div>
<div style="margin-top:6px; font-size:13px;">
      現在の超え率: <b><span id="freqNowLabel">--</span></b>（<span id="freqModeLabel">区間</span>）
    </div>
</div>
<div class="col" id="csvMinutesBlock"><label style="font-weight:600; display:block; margin-bottom:6px;">CSV出力期間（分）</label><input id="csvMinutes" min="1" step="1" style="width:6em;padding:4px;border-radius:6px;border:1px solid #445; background:#0e1726; color:#e6edf3;" type="number" value="3"/><div class="note" style="margin-top:4px;">※この分数以内（現在時刻から遡る）のイベントだけをCSVに書き出します（デフォルト3分）</div></div><div class="col" id="autoLogRow"><label style="font-weight:600; display:block; margin-bottom:6px;">SPAレベル自動記録</label><div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;"><label style="display:flex;align-items:center;gap:6px">
<input checked="" id="chkAutoSpaLog" type="checkbox"/> SPAレベル自動記録（≧）
          </label><input id="inpSpaLevelThresh" max="99" min="0" step="0.1" style="width:90px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;border-radius:8px;padding:6px 8px" type="number" value="2.1"/><select id="selSpaLevelTarget" style="padding:4px 6px;border-radius:8px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;"><option value="A">A</option><option value="B">B</option><option selected="" value="C">C</option></select><input id="logNote" placeholder="メモ（任意）" style="flex:1;min-width:180px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;border-radius:8px;padding:6px 8px" type="text"/></div></div></div>
<!-- ▲（移設）サンプリング速度 / 超え率モード -->
<hr style="border-color:#1a2236;margin:14px 0"/>
<div class="col">
<label>メモ</label>
<div class="note">SPAレベルは「直近の集計間隔」での平均SPAを用い、表示もその間隔ごとに更新します（ラッチ表示）。</div>
</div>
<div class="note">※ 初期表示を早くするために、ウォームアップ=60サンプル・2σ窓幅=120点・サンプリング=60Hzを初期値に設定しました。</div></div>
</div>
</div>
<script>
(function(){
  // ---------- Utilities ----------
  const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
  const randn=(()=>{ let spare=null; return ()=>{ if(spare!==null){ const v=spare; spare=null; return v; } let u=0,v=0,s=0; do{ u=Math.random()*2-1; v=Math.random()*2-1; s=u*u+v*v; }while(!s||s>=1); const mul=Math.sqrt(-2*Math.log(s)/s); spare=v*mul; return u*mul; };})();

  // erf 近似（Abramowitz & Stegun 7.1.26）
  function erf(x){
    const sign = Math.sign(x) || 1; x = Math.abs(x);
    const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
    const t=1/(1+p*x); const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
    return sign*y;
  }
  const Phi = z => 0.5*(1+erf(z/Math.SQRT2)); // 標準正規CDF

  // ---------- DOM ----------
  const canvas=document.getElementById('scope');
  const ctx=canvas.getContext('2d', { alpha:false, desynchronized:true });
  const intervalNote = document.getElementById('intervalNote');

  function resize(){ const dpr=1; const rect=canvas.getBoundingClientRect(); canvas.width=Math.floor(rect.width*dpr); canvas.height=Math.floor(rect.height*dpr); rebuildGrid(); }
  const gridCanvas = document.createElement('canvas'); const gg = gridCanvas.getContext('2d', {alpha:false});

  
  
  
  function rebuildGrid(){
    gridCanvas.width = canvas.width;
    gridCanvas.height = canvas.height;
    const w = gridCanvas.width, h = gridCanvas.height;
    gg.clearRect(0,0,w,h);

    const getSel = () => (document.getElementById('selBgStyle')?.value || 'straight');
    const style = getSel();

    function drawStraightGrid(strokeStyle='rgba(255,255,255,0.20)', gy=12, gx=24, dash=null){
      gg.save();
      gg.lineWidth = 1;
      gg.strokeStyle = strokeStyle;
      if (dash && gg.setLineDash) gg.setLineDash(dash);
      for(let i=0;i<=gy;i++){
        const y = Math.round(i*h/gy) + 0.5;
        gg.beginPath(); gg.moveTo(0,y); gg.lineTo(w,y); gg.stroke();
      }
      for(let x=0;x<=w;x+=gx){
        gg.beginPath(); gg.moveTo(x+0.5,0); gg.lineTo(x+0.5,h); gg.stroke();
      }
      if (dash && gg.setLineDash) gg.setLineDash([]);
      gg.restore();
    }

    function drawCurvedGrid(){
      const amp = 10, wave = 220, step = 8, alpha = 0.18;
      gg.lineWidth = 1;
      gg.strokeStyle = 'rgba(255,255,255,' + alpha + ')';
      const rows = 12;
      for (let i = 0; i <= rows; i++) {
        const y0 = Math.round(i * h / rows) + 0.5;
        gg.beginPath();
        for (let x = 0; x <= w; x += step) {
          const y = y0 + amp * Math.sin((x / wave) * 2 * Math.PI + i * 0.4);
          if (x === 0) gg.moveTo(x, y); else gg.lineTo(x, y);
        }
        gg.stroke();
      }
      const vspace = 24;
      for (let x0 = 0; x0 <= w; x0 += vspace) {
        gg.beginPath();
        for (let y = 0; y <= h; y += step) {
          const x = x0 + amp * Math.sin((y / wave) * 2 * Math.PI + x0 * 0.02);
          if (y === 0) gg.moveTo(x, y); else gg.lineTo(x, y);
        }
        gg.stroke();
      }
    }

    function drawRadar(){
      gg.save();
      gg.lineWidth = 1;
      gg.strokeStyle = 'rgba(255,255,255,0.15)';
      const cx = w/2, cy = h/2;
      const rays = 24;
      for(let i=0;i<rays;i++){
        const ang=(Math.PI*2*i)/rays;
        gg.beginPath();
        gg.moveTo(cx, cy);
        gg.lineTo(cx + Math.cos(ang)*w, cy + Math.sin(ang)*h);
        gg.stroke();
      }
      const rings = 10;
      const rstep = Math.min(w,h)/(rings*2);
      for(let i=1;i<=rings;i++){
        gg.beginPath();
        gg.arc(cx, cy, i*rstep, 0, Math.PI*2);
        gg.stroke();
      }
      gg.restore();
    }

    if (style === 'straight'){
      drawStraightGrid('rgba(255,255,255,0.20)', 12, 24, null);
    } else if (style === 'curved'){
      drawCurvedGrid();
    } else if (style === 'neon'){
      drawStraightGrid('rgba(0,200,255,0.22)', 12, 24, null);
    } else if (style === 'dot'){
      drawStraightGrid('rgba(255,255,255,0.15)', 12, 24, [2,6]);
    } else if (style === 'radar'){
      drawRadar();
    } else if (style === 'gradient'){
      gg.save();
      const grad = gg.createLinearGradient(0,0,0,h);
      grad.addColorStop(0,'rgba(0,200,255,0.20)');
      grad.addColorStop(1,'rgba(255,80,80,0.20)');
      gg.strokeStyle = grad;
      drawStraightGrid(grad, 12, 24, null);
      gg.restore();
    } else {
      drawStraightGrid('rgba(255,255,255,0.20)', 12, 24, null);
    }
  }

  resize(); addEventListener('resize', resize);
const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const audioStatus = document.getElementById('audioStatus');

  const inpN = document.getElementById('inpN');
  const inpSpeed = document.getElementById('inpSpeed');
  const speedLabel = document.getElementById('speedLabel');
  const inpSigma = document.getElementById('inpSigma');
  const inpAlpha = document.getElementById('inpAlpha');
  const alphaLabel = document.getElementById('alphaLabel');
  const inpThresh = document.getElementById('inpThresh');
  const selThreshMode=document.getElementById('selThreshMode');
  const selYMode = document.getElementById('selYMode');
  const inpYmax  = document.getElementById('inpYmax');
  const inpZwin  = document.getElementById('inpZwin');
  const selAudio = document.getElementById('selAudio');
  const selSpaMode = document.getElementById('selSpaMode');
  const inpWarm    = document.getElementById('inpWarm');
  const inpIntervalSec = document.getElementById('inpIntervalSec');const kpiP=document.getElementById('kpiP');
  const kpiSPA=document.getElementById('kpiSPA');
  const kpiLevel=document.getElementById('kpiLevel');
  const kpiLevelA=document.getElementById('kpiLevelA');
  const kpiLevelB=document.getElementById('kpiLevelB');
  const inpAvgSecA=document.getElementById('inpAvgSecA');
  const inpAvgSecB=document.getElementById('inpAvgSecB');
  const kpiLevelC=document.getElementById('kpiLevelC');
  const inpAvgSecC=document.getElementById('inpAvgSecC');


  // ---------- Audio ----------
  let AC=null, masterGain=null, audioReady=false;
  function ensureAudio(){
    try{
      if(!AC){ AC=new (window.AudioContext||window.webkitAudioContext)(); }
      if(AC.state==="suspended"){ AC.resume(); }
      if(!masterGain){ masterGain=AC.createGain(); masterGain.gain.value=0.12; masterGain.connect(AC.destination); }
      audioReady=true; audioStatus.textContent="音声: 有効"; audioStatus.style.color="#20c997";
    }catch(e){ console.warn(e); }
  }
  window.addEventListener('pointerdown', ()=>{ ensureAudio(); }, {once:false});

  
  function dynBeep(kind="th"){ // kind: 'th' (閾値) | 'z' (2σ)
    if(!audioReady || selAudio.value==="off") return;
    const now = AC.currentTime;
    const mast = masterGain;
    function tone(f0, dur=0.12, sweepTo=null, gain=0.12, type="sine"){
      const o=AC.createOscillator(); const g=AC.createGain();
      o.type=type;
      o.frequency.setValueAtTime(Math.max(40, f0), now);
      if(sweepTo && isFinite(sweepTo)){
        o.frequency.exponentialRampToValueAtTime(Math.max(40, sweepTo), now + dur*0.9);
      }
      // ADSR-ish envelope
      const a=0.02, d=0.08, sLvl=gain*0.5, r=0.06;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(gain, now + a);
      g.gain.exponentialRampToValueAtTime(sLvl, now + a + d);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.connect(g).connect(mast);
      o.start(now);
      o.stop(now + dur + r);
    }
    function chord(base, dur){
      tone(base, dur, base*1.8, 0.14, "sine");     // 基音：上昇スイープ
      tone(base*1.5, dur, base*2.6, 0.08, "square"); // 5度：倍音強め
    }
    if(kind === "z"){
      // 2σ超え：二連チャイム（上昇スイープ×2）
      chord(900, 0.18);
      setTimeout(()=>chord(900, 0.18), 100);
    }else{
      // 閾値超え：軽めのワンショット（上昇スイープ）
      tone(650, 0.12, 1000, 0.10, "sine");
      tone(975, 0.10, 1500, 0.05, "triangle"); // 5度の薄いハーモニー
    }
  }


  
  // ---- Vibrate gating by SPA instant/A/B ----
  function shouldVibrateBySpa(){
    const bySpaEl = document.getElementById('chkVibeBySpa');
    if (!bySpaEl || !bySpaEl.checked) return true; // if OFF, allow as before

    const useInst = !!(document.getElementById('chkVibeInst')?.checked);
    const useA = !!(document.getElementById('chkVibeA')?.checked);
    const useB = !!(document.getElementById('chkVibeB')?.checked);

    // thresholds
    let thInst, thA, thB;
    const own = !!(document.getElementById('chkVibeOwnThresh')?.checked);
    if (own){
      const f = id => parseFloat(document.getElementById(id)?.value || '2.1');
      thInst = f('inpVibeInstThresh'); thA = f('inpVibeAThresh'); thB = f('inpVibeBThresh');
    } else {
      const th = parseFloat(document.getElementById('inpSpaLevelThresh')?.value || '2.1');
      thInst = thA = thB = th;
    }

    const okInst = useInst && (typeof instLevel === 'number') && (instLevel >= thInst);
    const okA = useA && (typeof A === 'number') && (A >= thA);
    const okB = useB && (typeof B === 'number') && (B >= thB);
    return (okInst || okA || okB);
  }

  // ---------- State ----------
  let N = parseInt(inpN.value,10);
  let buffer = new Float32Array(N).fill(0);
  let head = N-1; let x = 0;
  // Overlay (second series)
  let buffer2 = new Float32Array(N).fill(0);
  let head2 = N-1; let x2 = 0; let running=false;
  let sampleIntervalMs = 1000/parseFloat(inpSpeed.value);
  let sigma = parseFloat(inpSigma.value);
  let alpha = parseFloat(inpAlpha.value);
  let threshold = parseFloat(inpThresh.value);
  let zWindow = parseInt(inpZwin.value,10);
  let warmupSamples = parseInt(inpWarm.value,10);
  let intervalSec = parseFloat(inpIntervalSec.value);

  


  // === 軽量シード：Z窓のみ事前充填（見た目は0開始、統計だけ安定） ===
  function seedZWindowOnly(){
    try{
      const std0 = parseFloat(inpSigma?.value) || 1;
      rebuildZ(zWindow);
      for (let i=0; i<zWindow; i++){ pushZ(std0); } // 平均0,分散~std0^2の近似として一定値投入
      // 超え率はクリア（累積は開始後に自然に貯める）
      totalSamples = 0;
      exceedCount  = 0;
    }catch(e){
      console.warn('seedZWindowOnly failed:', e);
    }
  }

  // === Calm-start parameters for SPAレベルA ===
  let A_STARTUP_GRACE_MS = 2000;  // 開始直後はAのラッチを最低この時間は遅らせる
  let A_MIN_FILL_RATIO   = 0.75;  // Aの平均窓の最低充足率

// 2σ用：O(1)ローリング統計（合計・二乗和）
  let zBuf = new Float32Array(zWindow);
  let zHead = -1, zCount = 0, zSum = 0, zSumSq = 0;
  function rebuildZ(windowSize){
    zBuf = new Float32Array(windowSize); zHead=-1; zCount=0; zSum=0; zSumSq=0;
  }

  function pushZ(v){
    zHead = (zHead + 1) % zWindow;
    if (zCount < zWindow){
      zBuf[zHead] = v; zSum += v; zSumSq += v*v; zCount++;
    } else {
      const old = zBuf[zHead];
      zBuf[zHead] = v;
      zSum += v - old;
      zSumSq += v*v - old*old;
    }
  }
  function rollingStatsFast(){
    const m = zCount || 1;
    const mean = zSum / m;
    const var_ = (zSumSq - (zSum*zSum)/m) / Math.max(1, m-1);
    return { mean, std: Math.sqrt(var_) || 1, count: zCount };
  }

  // stats（頻度SPA用）
  let totalSamples=0; let exceedCount=0;
  let p_freq_raw = 0;

  // 区間平均SPAのためのバッファ（時刻付き）
  const spaTimes = []; const spaVals = [];
  // A/B ラッチ更新用の状態
  let lastALatched = null, lastBLatched = null;
  let nextLatchA = (typeof performance!=='undefined' ? performance.now() : Date.now());
  let nextLatchB = (typeof performance!=='undefined' ? performance.now() : Date.now());
  // A/B 専用の期間窓（時刻付き）
  const winAT = []; const winAV = [];
  const winBT = []; const winBV = [];
  // C ラッチ＆期間窓／累積
  let lastCLatched = null;
  let nextLatchC = (typeof performance!=='undefined' ? performance.now() : Date.now());
  const winCT = []; const winCV = [];
  let cumSpaSum = 0, cumSpaCount = 0;
  let lastDisplay = {p:null, spa:null, level:null};
  let nextLatchTime = performance.now() + intervalSec*1000;

  function spaLevelText(spa){
    if (isNaN(spa) || !isFinite(spa)) return '—';
    if (spa < 1)   return 'LOW';
    if (spa < 2)   return 'MID';
    if (spa < 3)   return 'HIGH';
    if (spa < 4)   return 'V.HIGH';
    return 'EXTREME';
  }

  function reset(){
    buffer = new Float32Array(N).fill(0); head=N-1; x=0;
    buffer2 = new Float32Array(N).fill(0); head2=N-1; x2=0;
    totalSamples=0; exceedCount=0;
    zBuf.fill(0); zHead=-1; zCount=0; zSum=0; zSumSq=0;
    spaTimes.length=0; spaVals.length=0;
    lastDisplay={p:null,spa:null,level:null};
    nextLatchTime = performance.now() + intervalSec*1000;
  }

  function reallocate(newN){
    const old=buffer; const copyLen=Math.min(old.length,newN); const next=new Float32Array(newN).fill(0);
    for(let i=0;i<copyLen;i++){ next[newN-1-i]=old[old.length-1-i]; }
    buffer=next; N=newN; head=N-1;
    // overlay
    const old2=buffer2; const copyLen2=Math.min(old2.length,newN); const next2=new Float32Array(newN).fill(0);
    for(let i=0;i<copyLen2;i++){ next2[newN-1-i]=old2[old2.length-1-i]; }
    buffer2=next2; head2=N-1;
  }
  function add(v){ head=(head+1)%N; buffer[head]=v; }
  function getAt(i){ const idx=(head-(N-1-i)); const j=(idx>=0)?(idx%N):((idx%N)+N); return buffer[j]; }
  function add2(v){ head2=(head2+1)%N; buffer2[head2]=v; }
  function getAt2(i){ const idx=(head2-(N-1-i)); const j=(idx>=0)?(idx%N):((idx%N)+N); return buffer2[j]; }

  // ---------- Simulation (with interval latch) ----------
  let accum = 0, lastSim = performance.now(), lastDraw = performance.now();
  
  let startAtTs = null;
const MAX_STEPS_PER_FRAME = 256;
  const DRAW_INTERVAL_MS = 1000/60;

  function simulateStep(now){
    
    // --- Noise update (switchable) ---
    const selNoise = document.getElementById('selNoise');
    if (selNoise && selNoise.value === 'iid'){
      x = sigma * randn();
    } else {
      const drifted = (1 - alpha) * x + sigma * randn();
      x = drifted;
    }

    add(x); pushZ(x);
    // --- Update overlay series (opposite noise model) ---
    (function(){
      const selNoise = document.getElementById('selNoise');
      if (selNoise && selNoise.value === 'iid'){
        x2 = (1 - alpha) * x2 + sigma * randn();
      } else {
        x2 = sigma * randn();
      }
      add2(x2);
    })();

    
    let z;
    const selZbasis = document.getElementById('selZbasis');
    if (selZbasis && selZbasis.value === 'theory'){
      // Theory-based Z
      const selNoise2 = document.getElementById('selNoise');
      const a = Math.max(1e-6, parseFloat(inpAlpha?.value)||0.1);
      const sig = Math.max(1e-9, parseFloat(inpSigma?.value)||1);
      let std_theory;
      if (selNoise2 && selNoise2.value === 'iid'){
        std_theory = sig; // IID: Var=σ²
      } else {
        const denom = Math.sqrt(Math.max(1e-9, 2*a - a*a));
        std_theory = sig / (denom || 1); // AR1: Var=σ²/(2α-α²)
      }
      z = x / (std_theory || 1);
    } else {
      const stats = rollingStatsFast();
      z = (x - stats.mean) / (stats.std || 1);
    }


    let exceeded=false, zExceeded=false;
    if(selThreshMode.value==='abs'){ exceeded = Math.abs(x) >= threshold; } else { exceeded = Math.abs(z) >= threshold; }
    zExceeded = Math.abs(z) >= 2.0;

    totalSamples++; if(exceeded) exceedCount++;
    if(zExceeded){ dynBeep('z');
      if (document.getElementById('chkStrongFX')?.checked && 'vibrate' in navigator) { try { if (shouldVibrateBySpa()) { /*tone-vibe disabled*/ false && navigator.vibrate([140,80,140]); } } catch(e){} }try{ logEvent('z', {spa: spaVals.length? spaVals[spaVals.length-1]: null, p: null}); }catch(e){} } else if(exceeded){ dynBeep('th');
      if (document.getElementById('chkStrongFX')?.checked && 'vibrate' in navigator) { try { if (shouldVibrateBySpa()) { /*tone-vibe disabled*/ false && vibrateByA(lastALatched, th, 1.0); } } catch(e){} }try{ logEvent('th', {spa: spaVals.length? spaVals[spaVals.length-1]: null, p: null}); }catch(e){} }

    // 周波数ベース指標は継続更新
    p_freq_raw = exceedCount / Math.max(1,totalSamples);

    // p/SPA（瞬間）→ バッファに保存（ウォームアップ後）
    if(totalSamples >= warmupSamples && zCount >= zWindow){
      const mode = selSpaMode.value;
      let p_show = null;
      if(mode === 'freq'){
        const p_freq = (exceedCount + 1) / (totalSamples + 2);
        p_show = p_freq;
      }else if(mode === 'freq_inv'){
        // 逆頻度SPA：超過が多いほど SPA を高く（= -log10(1 - rate)）
        const rate = (exceedCount + 1) / (totalSamples + 2);
        const p_inv = Math.max(Number.EPSILON, 1 - Math.min(1, Math.max(0, rate)));
        p_show = p_inv;
      }else if(mode === 'inst'){
        const p_inst = 2*(1 - Phi(Math.abs(z)));
        p_show = Math.max(Number.EPSILON, Math.min(1, p_inst));
      }else if(mode === 'batch'){
        const p_inst = 2*(1 - Phi(Math.abs(z)));
        const m = Math.max(1, stats.count);
        const p_batch = 1 - Math.pow(1 - p_inst, m);
        p_show = Math.max(Number.EPSILON, Math.min(1, p_batch));
      }
      if(p_show!=null){
        const spa = -Math.log10(p_show);
        spaTimes.push(now); spaVals.push(spa);
        // A/B windows
        const secA = Math.max(0.1, parseFloat(inpAvgSecA?.value)||1);
        const secB = Math.max(0.1, parseFloat(inpAvgSecB?.value)||5);
        winAT.push(now); winAV.push(spa);
        winBT.push(now); winBV.push(spa);
        const cutA = now - secA*1000; const cutB = now - secB*1000;
        while(winAT.length && winAT[0] < cutA){ winAT.shift(); winAV.shift(); }
        while(winBT.length && winBT[0] < cutB){ winBT.shift(); winBV.shift(); }
        // --- ラッチ更新（A/Bそれぞれの周期で更新） ---
        if(now >= nextLatchA){
          if(winAV.length){ let s=0; for(let i=0;i<winAV.length;i++){ s+=winAV[i]; }
            const avgA = s/winAV.length; lastALatched = avgA*2.44; } else { lastALatched = null; }
          // --- Injected: A-only vibration trigger (consecutive, no cooldown) ---
          try {
            const bySpaEl = document.getElementById('chkVibeBySpa');
            const useA = !!(document.getElementById('chkVibeA')?.checked);
            const own = !!(document.getElementById('chkVibeOwnThresh')?.checked);
            const th = own
              ? parseFloat(document.getElementById('inpVibeAThresh')?.value || '2.0')
              : parseFloat(document.getElementById('inpSpaLevelThresh')?.value || '2.0');
            if (bySpaEl && bySpaEl.checked && useA && typeof navigator !== 'undefined' && 'vibrate' in navigator) {
              if (typeof lastALatched === 'number' && lastALatched >= th) {
                vibrateByA(lastALatched, th, 1.0); // short buzz; will re-fire every A latch interval while condition holds
              }
            }
          } catch (e) { /* ignore */ }

          nextLatchA = now + secA*1000;
        }
        if(now >= nextLatchB){
          if(winBV.length){ let s=0; for(let i=0;i<winBV.length;i++){ s+=winBV[i]; }
            const avgB = s/winBV.length; lastBLatched = avgB*2.44; } else { lastBLatched = null; }
          nextLatchB = now + secB*1000;
        }
      
        // C 期間（0 => 全時間）
        const secC = Math.max(0, parseFloat(inpAvgSecC?.value)||0);
        if (secC > 0) {
          // windowed C
          winCT.push(now); winCV.push(spa);
          const cutC = now - secC*1000;
          while(winCT.length && winCT[0] < cutC){ winCT.shift(); winCV.shift(); }
        } else {
          // cumulative C
          cumSpaSum += spa; cumSpaCount += 1;
        }
        // --- ラッチ更新（Cの周期で更新：secC秒 / 0のとき1秒） ---
        if (now >= nextLatchC){
          let avgC = null;
          if (secC > 0) {
            if (winCV.length){ let s=0; for(let i=0;i<winCV.length;i++){ s+=winCV[i]; } avgC = s/winCV.length; }
          } else {
            if (cumSpaCount > 0){ avgC = cumSpaSum / cumSpaCount; }
          }
          lastCLatched = (avgC!=null) ? (avgC*2.44) : null;
          nextLatchC = now + (secC>0 ? secC*1000 : 1000);
        }
}
    }

    // 古いSPAを捨てる（直近intervalSecのみ保持）
    const cut = now - intervalSec*1000;
    while(spaTimes.length && spaTimes[0] < cut){ spaTimes.shift(); spaVals.shift(); }

    // ラッチ更新：一定間隔ごとに平均SPAで表示を更新
    if(now >= nextLatchTime){
      if(spaVals.length){
        const avgSpa = spaVals.reduce((a,b)=>a+b,0)/spaVals.length;
        const avgP = Math.pow(10, -avgSpa);
        const level = spaLevelText(avgSpa);
        lastDisplay = { p: avgP.toFixed(6), spa: avgSpa.toFixed(2), level: (avgSpa*2.44).toFixed(1) + " / " + level };
      }else{
        lastDisplay = { p: '—', spa: '—', level: '—' };
      }
      nextLatchTime = now + intervalSec*1000;
    }
  }

  function loop(now){
    const dt = now - lastSim; lastSim = now; accum += dt;
    const tick = sampleIntervalMs; let steps = 0;
    while(accum >= tick && steps < MAX_STEPS_PER_FRAME){ simulateStep(now); accum -= tick; steps++; }
    if(now - lastDraw >= DRAW_INTERVAL_MS){ draw(); lastDraw = now; }
    requestAnimationFrame(loop);
  }

  // ---------- Drawing ----------
  function draw(){
    const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h);
    ctx.drawImage(gridCanvas, 0, 0);

    // y scale
    let yMin,yMax;
    if(selYMode.value==='fixed'){ const ymax=Math.max(2, parseFloat(inpYmax.value)); yMin=-ymax; yMax=ymax; }
    else{
      let mn=Infinity,mx=-Infinity, step=Math.max(1, Math.floor(N/8));
      for(let i=0;i<N;i+=step){
        const v=getAt(i); if(v<mn) mn=v; if(v>mx) mx=v;
        const v2=getAt2(i); if(v2<mn) mn=v2; if(v2>mx) mx=v2;
      }
      const marg=0.2*Math.max(1,(mx-mn)||1); yMin=mn-marg; yMax=mx+marg; if(!isFinite(yMin)||!isFinite(yMax)||yMin===yMax){ yMin=-10; yMax=10; }
    }
    const yToPix = val => h - (val - yMin) * (h/(yMax - yMin));

    // zero
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); const y0=yToPix(0); ctx.moveTo(0,y0); ctx.lineTo(w,y0); ctx.stroke();

    // plot
    ctx.lineWidth = 2; ctx.strokeStyle = "#6fd3ff"; ctx.beginPath();
    for(let i=0;i<N;i++){
      const val=getAt(i); const xx=i*w/(N-1); const yy=yToPix(val);
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    // overlay line
    ctx.lineWidth = 1.5; ctx.strokeStyle = "#ff7a7a";
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const val=getAt2(i); const xx=i*w/(N-1); const yy=yToPix(val);
      if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    // 閾値ライン（abs時）
    if(selThreshMode.value==='abs'){
      const thr=Math.abs(threshold);
      ctx.strokeStyle="rgba(255,184,107,0.9)";
      ctx.beginPath(); ctx.moveTo(0,yToPix(thr)); ctx.lineTo(w,yToPix(thr)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,yToPix(-thr)); ctx.lineTo(w,yToPix(-thr)); ctx.stroke();
    }

    // 2σ線
    const stats = rollingStatsFast();
    const upper=stats.mean + 2*stats.std, lower=stats.mean - 2*stats.std;
    ctx.strokeStyle="rgba(255,107,107,0.9)";
    ctx.beginPath(); ctx.moveTo(0,yToPix(upper)); ctx.lineTo(w,yToPix(upper)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,yToPix(lower)); ctx.lineTo(w,yToPix(lower)); ctx.stroke();

    // KPI（ラッチ表示）kpiP.textContent = lastDisplay.p ?? '—';
    kpiSPA.textContent = lastDisplay.spa ?? '—';
    kpiLevel.textContent = lastDisplay.level ?? '—';
  
    // A/B latched SPA level display (updates every A秒 / B秒)
    function r1(x){ return (Math.round(x*10)/10).toFixed(1); }
    
    // C専用：小数点以下2桁表示（下三桁四捨五入）
    function r2(x){ return (Math.round(x*100)/100).toFixed(2); }
if(kpiLevelA){ kpiLevelA.textContent = (lastALatched!=null) ? r1(lastALatched) : '—'; }
    if(kpiLevelB){ kpiLevelB.textContent = (lastBLatched!=null) ? r1(lastBLatched) : '—'; }

    if(kpiLevelC){ kpiLevelC.textContent = (lastCLatched!=null) ? r2(lastCLatched) : '—'; }
}

  // ---------- Wire UI ----------
  btnStart.addEventListener('click', ()=>{
    ensureAudio();
    // --- warm start fix: full reset & timer rebase ---
    try { if (typeof reset === 'function') reset(); 
  startAtTs = (typeof performance!=='undefined' ? performance.now() : Date.now());
  seedZWindowOnly();
} catch(_) {}
    const now = (typeof performance!=='undefined' ? performance.now() : Date.now());
    // rebase simulation timers
    accum = 0; lastSim = now; lastDraw = now;
    // re-read intervals from UI
    try {
      const intervalSec_ = Math.max(0.1, parseFloat(inpIntervalSec?.value)||5);
      nextLatchTime = now + intervalSec_*1000;
      const secA = Math.max(0.1, parseFloat(inpAvgSecA?.value)||1);
      const secB = Math.max(0.1, parseFloat(inpAvgSecB?.value)||5);
      const secC = Math.max(0.1, parseFloat(inpAvgSecC?.value)||60);
      nextLatchA = now + secA*1000;
      nextLatchB = now + secB*1000;
      nextLatchC = now + secC*1000;
    } catch(_) {}
    requestAnimationFrame(loop);
  });
  btnStop .addEventListener('click', ()=>{ /* ループは停止させず描画のみ止めるのではなく、完全停止 */ location.reload(); });
  btnReset.addEventListener('click', ()=>{ reset(); draw(); });

  inpN.addEventListener('change', ()=>{ const v=clamp(parseInt(inpN.value,10)||1200,100,5000); inpN.value=v; reallocate(v); draw(); });
  inpSpeed.addEventListener('input', ()=>{ sampleIntervalMs = 1000/parseFloat(inpSpeed.value); speedLabel.textContent = inpSpeed.value + " sps"; });
  inpSigma.addEventListener('change', ()=>{ sigma = parseFloat(inpSigma.value)||1; });
  inpAlpha.addEventListener('input', ()=>{ alpha=parseFloat(inpAlpha.value)||0; alphaLabel.textContent = "α = " + alpha.toFixed(3); });
  inpThresh.addEventListener('change', ()=>{ threshold = Math.abs(parseFloat(inpThresh.value)||6); });
  selThreshMode.addEventListener('change', draw);
  selYMode.addEventListener('change', draw);
  inpYmax.addEventListener('change', draw);
  inpZwin.addEventListener('change', ()=>{
    const v = clamp(parseInt(inpZwin.value,10)||400,30,2000);
    if(v !== zWindow){
      // 既存データから再構築
      const tmp = new Float32Array(v);
      let count = 0;
      for(let i=0;i<v && i<N;i++){ tmp[i] = getAt(N-1-i); count++; }
      zWindow = v; rebuildZ(zWindow);
      for(let i=count-1;i>=0;i--){ pushZ(tmp[i]); }
    }
  });
  selSpaMode.addEventListener('change', ()=>{});
  inpWarm.addEventListener('change', ()=>{ warmupSamples = clamp(parseInt(inpWarm.value,10)||0,0,5000); });
  inpIntervalSec.addEventListener('change', ()=>{
    intervalSec = Math.max(1, Math.min(30, parseFloat(inpIntervalSec.value)||5));
    inpIntervalSec.value = intervalSec;
    intervalNote.textContent = "集計間隔: " + intervalSec.toFixed(1) + " 秒";
  });

  // initial render
  draw();

  (function(){var s=document.getElementById('selBgStyle'); if(s){ s.addEventListener('change', rebuildGrid); }})();

  // ---------- GPS / Geolocation ----------
  const btnGeoStart = document.getElementById('btnGeoStart');
  const btnGeoStop  = document.getElementById('btnGeoStop');
  const btnGeoCopy  = document.getElementById('btnGeoCopy');
  const geoLat = document.getElementById('geoLat');
  const geoLon = document.getElementById('geoLon');
  const geoAcc = document.getElementById('geoAcc');
  const geoSpd = document.getElementById('geoSpd');
  const geoHead= document.getElementById('geoHead');
  const geoTime= document.getElementById('geoTime');
  const geoStatus = document.getElementById('geoStatus');
  const chkAttachLoc = document.getElementById('chkAttachLoc');
  const btnExportCSV = document.getElementById('btnExportCSV');

  let geoWatchId = null;
  let lastGeo = null; // {lat, lon, acc, spd, head, ts}

  function fmt(n, d=6){ return (typeof n==='number' && isFinite(n)) ? n.toFixed(d) : '—'; }
  function iso(t){ try{ return new Date(t).toISOString(); }catch(e){ return '—'; } }

  function startGeo(){
    if(!('geolocation' in navigator)){
      geoStatus.textContent = 'GPS: 非対応ブラウザ';
      return;
    }
    if(geoWatchId!==null){ geoStatus.textContent='GPS: 実行中'; return; }
    geoStatus.textContent='GPS: 起動中…（ブラウザの許可を確認）';
    geoWatchId = navigator.geolocation.watchPosition(
      pos => {
        const c = pos.coords;
        lastGeo = {
          lat: c.latitude, lon: c.longitude,
          acc: c.accuracy, spd: (c.speed!=null? c.speed : NaN),
          head: (c.heading!=null? c.heading : NaN),
          ts: pos.timestamp
        };
        geoLat.value = fmt(lastGeo.lat, 6);
        geoLon.value = fmt(lastGeo.lon, 6);
        geoAcc.value = fmt(lastGeo.acc, 1);
        geoSpd.value = isFinite(lastGeo.spd)? fmt(lastGeo.spd, 2) : '—';
        geoHead.value= isFinite(lastGeo.head)? fmt(lastGeo.head, 1) : '—';
        geoTime.value = formatJST(pos && pos.timestamp ? pos.timestamp : (Date.now())) ;
        geoStatus.textContent = 'GPS: 受信中（高精度）';
      },
      err => {
        geoStatus.textContent = 'GPSエラー: ' + (err && err.message ? err.message : String(err));
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }
    );
  }
  function stopGeo(){
    if(geoWatchId!=null){
      try{ navigator.geolocation.clearWatch(geoWatchId); }catch(e){}
      geoWatchId = null;
      geoStatus.textContent = 'GPS: 停止';
    }
  }
  function copyCoords(){
    const txt = (lastGeo? (lastGeo.lat + ',' + lastGeo.lon) : '—');
    navigator.clipboard && navigator.clipboard.writeText(txt).then(()=>{
      geoStatus.textContent = '座標をクリップボードにコピーしました';
    }).catch(()=>{
      geoStatus.textContent = 'コピーできませんでした';
    });
  }

  btnGeoStart.addEventListener('click', startGeo);
  btnGeoStop .addEventListener('click', stopGeo);
  btnGeoCopy .addEventListener('click', copyCoords);

  // ---------- Event logging with GPS ----------
  const eventLog = []; // {timeISO, epoch, type:'th'|'z', spa?, p?, lat?, lon?, acc?}
  function logEvent(kind, meta={}){
    if(!chkAttachLoc.checked) return;
    const g = lastGeo || {};
    const rec = {
      timeISO: new Date().toISOString(),
      epoch: Date.now(),
      type: kind,
      spa: (meta && typeof meta.spa==='number') ? meta.spa : null,
      p: (meta && typeof meta.p==='number') ? meta.p : null,
      lat: (typeof g.lat==='number')? g.lat : null,
      lon: (typeof g.lon==='number')? g.lon : null,
      acc: (typeof g.acc==='number')? g.acc : null,
      spd: (typeof g.spd==='number')? g.spd : null,
      head:(typeof g.head==='number')? g.head : null
    };
    eventLog.push(rec);
  }
  function exportCSV(){
    if(!eventLog.length){
      geoStatus.textContent = 'エクスポート対象のイベントがありません';
      return;
    }
    
    // --- CSV window filtering by minutes ---
    try {
      var minBox = document.getElementById('csvMinutes');
      var minVal = minBox ? parseFloat(minBox.value) : 3;
      if (!isFinite(minVal) || minVal <= 0) minVal = 3;
      var now = Date.now();
      var cutoff = now - Math.round(minVal * 60 * 1000);
      if (Array.isArray(eventLog) && eventLog.length) {
        eventLog = eventLog.filter(function(r){
          var e = (r && typeof r.epoch === 'number') ? r.epoch : 0;
          return e >= cutoff;
        });
      }
    } catch(e) { /* ignore */ }
    // ---------------------------------------
const header = ['timeISO','epoch','type','spa','p','lat','lon','acc','spd','head','place','note','observer'];
    const rows = [header.join(',')].concat(
      eventLog.map(r => header.map(k => (r[k]==null? '' : r[k])).join(','))
    );
    const blob = new Blob(['\ufeff' + rows.join('\r\n')], {type:'text/csv;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = window.makeCsvFilename();
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    geoStatus.textContent = 'CSVを書き出しました（ダウンロードを確認）';
  }
  btnExportCSV.addEventListener('click', exportCSV);


  // ---- Place (manual) wiring ----
  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const btnSetPlace = document.getElementById('btnSetPlace');
  const btnClearPlace = document.getElementById('btnClearPlace');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  const btnManualLog = document.getElementById('btnManualLog');
  let currentPlace = { name: '', memo: '' };
let currentObserver = '';
const observerNameEl = document.getElementById('observerName');
function setObserverName(){
  currentObserver = (observerNameEl && observerNameEl.value) ? String(observerNameEl.value).trim() : '';
  var geoStatus = document.getElementById('geoStatus');
  
  try{
    if(observerNameEl){
      if(currentObserver){
        observerNameEl.style.background = '#ffffff';
        observerNameEl.style.color = '#000000';
      }else{
        observerNameEl.style.background = '';
        observerNameEl.style.color = '';
      }
    }
  }catch(e){}  
if(geoStatus){ geoStatus.textContent = currentObserver ? ('観測者: ' + currentObserver) : '観測者は未設定'; }
}
observerNameEl && observerNameEl.addEventListener('change', setObserverName);
observerNameEl && observerNameEl.addEventListener('input', setObserverName);

  function setCurrentPlace(){
    currentPlace = { name: (placeNameEl.value||'').trim(), memo: (placeMemoEl.value||'').trim() };
    if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent = currentPlace.name ? ('場所をセット: ' + currentPlace.name) : '場所をクリアしました'; }
  }
  function clearPlace(){
    placeNameEl.value=''; placeMemoEl.value=''; currentPlace = {name:'', memo:''};
    if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent='場所をクリアしました'; }
  }
  btnSetPlace && btnSetPlace.addEventListener('click', setCurrentPlace);
  btnClearPlace && btnClearPlace.addEventListener('click', clearPlace);

  // keep original reference
  const __origLogEvent = (typeof logEvent==='function') ? logEvent : null;
  function logEvent(kind, meta={}){
    if(!__origLogEvent) return;
    const include = (chkIncludePlace && chkIncludePlace.checked);
    const placeStr = include ? (currentPlace.name || placeNameEl.value || '') : '';
    const noteStr  = (meta && typeof meta.note==='string') ? meta.note : (placeMemoEl ? placeMemoEl.value : '');
    const meta2 = Object.assign({}, meta, { place: placeStr, note: noteStr ,
      observer: (typeof meta.observer === 'string' ? meta.observer : (document.getElementById('observerName')?.value?.trim() || '')),
    observer: observerVal,
      observer: (typeof meta.observer === 'string' ? meta.observer : '')});
    // Forward to original
    meta2.observer = currentObserver;
__origLogEvent(kind, meta2);
  }

  // manual log button
  btnManualLog && btnManualLog.addEventListener('click', ()=>{
    try{
      const spaTxt = (document.getElementById('kpiSPA')||{}).textContent || '';
      const pTxt = (document.getElementById('kpiP')||{}).textContent || '';
      const spa = parseFloat(spaTxt); const p = parseFloat(pTxt);
      logEvent('manual', {spa: isFinite(spa)? spa : null, p: isFinite(p)? p : null});
      if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent='現在の状態を記録しました'; }
    }catch(e){}
  });


  // ---- Override GPS timestamp display to JST ----
  function formatJST(ts){
    try{
      const d = new Date(ts);
      return d.toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
    }catch(e){ return ts; }
  }
  const __geoSuccess = (typeof geoSuccess === 'function') ? geoSuccess : null;
  function geoSuccess(pos){
    if(!__geoSuccess) return;
    __geoSuccess(pos);
    try{
      const tEl = document.getElementById('geoTime');
      if(tEl && pos.timestamp){ tEl.value = formatJST(pos.timestamp); }
    }catch(e){}
  }


// expose latched levels for other scripts
try{
  window.getLatchedLevels = () => ({ A: lastALatched, B: lastBLatched, C: lastCLatched });
}catch(e){}

  // --- 復帰（バックグラウンド→フォアグラウンド）時の自動リセット＆タイマ再ベース ---
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) return;             // 非表示→表示になった時だけ実行

    try { if (typeof ensureAudio === 'function') ensureAudio(); } catch(_) {}
    try { if (typeof reset === 'function') reset(); } catch(_) {}

    const now = (typeof performance !== 'undefined' ? performance.now() : Date.now());
    try {
      accum = 0;
      lastSim = now;
      lastDraw = now;

      const _intervalSec = Math.max(0.1, parseFloat(inpIntervalSec?.value) || 1);
      nextLatchTime = now + _intervalSec * 1000;

      const secA = Math.max(0.1, parseFloat(inpAvgSecA?.value) || 1);
      const secB = Math.max(0.1, parseFloat(inpAvgSecB?.value) || 3);
      const secC = Math.max(0.1, parseFloat(inpAvgSecC?.value) || 0);

      nextLatchA = now + secA * 1000;
      nextLatchB = now + secB * 1000;
      nextLatchC = now + (secC > 0 ? secC * 1000 : 1000);
    } catch (_) {}
  });

})();</script>
<script>
(function(){
  // --- 安全なロガーに置換（座標OFFでも記録する） ---
  const geoLat = document.getElementById('geoLat');
  const geoLon = document.getElementById('geoLon');
  const geoAcc = document.getElementById('geoAcc');
  const geoSpd = document.getElementById('geoSpd');
  const geoHead= document.getElementById('geoHead');
  const geoStatus = document.getElementById('geoStatus');
  const chkAttachLoc = document.getElementById('chkAttachLoc');
  const btnExportCSV = document.getElementById('btnExportCSV');

  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  const btnManualLog = document.getElementById('btnManualLog');

  const chkAutoSpaLog = document.getElementById('chkAutoSpaLog');
  const inpSpaLevelThresh = document.getElementById('inpSpaLevelThresh');
  const logNote = document.getElementById('logNote');

  // 既存 eventLog を利用 or 作成
  // persistent event log (localStorage)
function loadEventLog(){
  try{
    const s = localStorage.getItem('spa_event_log');
    if(!s) return [];
    const arr = JSON.parse(s);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function saveEventLog(){
  try{
    localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[]));
  }catch(e){}
}
window.eventLog = loadEventLog();

  function formatJST(ts){
    try{
      const d = new Date(ts);
      return d.toLocaleString('ja-JP', {
        timeZone: 'Asia/Tokyo',
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
    }catch(e){ return String(ts); }
  }
  function nowJST(){ return formatJST(Date.now()); }

  function readGPS(){
    const pf=v=>{ const x=parseFloat(v); return Number.isFinite(x)? x : null; };
    return {
      lat: pf(geoLat?.value), lon: pf(geoLon?.value), acc: pf(geoAcc?.value),
      spd: pf(geoSpd?.value), head: pf(geoHead?.value)
    };
  }

  // 元の関数名 logEvent を安全版で上書き

function readLatchedLevelsFromDOM(){
  function num(txt){ 
    var t = (txt||'').toString().replace(/[^\d\.\-]/g,''); 
    var v = parseFloat(t); 
    return (isFinite(v)? v : null); 
  }
  var A = num((document.getElementById('kpiLevelA')||{}).textContent || '');
  var B = num((document.getElementById('kpiLevelB')||{}).textContent || '');
  var C = num((document.getElementById('kpiLevelC')||{}).textContent || '');
  return {A:A, B:B, C:C};
}

window.logEvent = function(kind, meta = {}){
  const obEl = document.getElementById('observerName');
  const observerVal = (meta && typeof meta.observer === 'string' && meta.observer.trim())
    ? meta.observer.trim()
    : (obEl && obEl.value ? String(obEl.value).trim() : '');
const rec = {
    timeISO: nowJST(),
    epoch: Date.now(),
    type: kind,
    levelA, levelB, levelC,
    level: (typeof meta.level === 'number') ? meta.level
          : (typeof meta.spa === 'number' ? (meta.spa*2.44) : (levelC ?? levelB ?? levelA ?? null)),
    spa:   (typeof meta.spa === 'number') ? meta.spa : null,
    p:     (typeof meta.p   === 'number') ? meta.p   : null,
    lat: gps.lat, lon: gps.lon, acc: gps.acc, spd: gps.spd, head: gps.head,
    place: includePlace ? ((meta.place!=null? meta.place : (placeNameEl? placeNameEl.value : '')) || '') : '',
    note:  (meta.note!=null? meta.note : (placeMemoEl? placeMemoEl.value : '')) || ''
  ,
    observer: (typeof meta.observer === 'string' ? meta.observer : '')};
  window.eventLog.push(rec); saveEventLog();
  try{ saveEventLog(); }catch(e){}
  try{ if(geoStatus) geoStatus.textContent='記録: ' + kind; }catch(e){}
};
    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind,
      level: (typeof meta.level === 'number') ? meta.level : null,
      spa:   (typeof meta.spa   === 'number') ? meta.spa   : null,
      p:     (typeof meta.p     === 'number') ? meta.p     : null,
      lat: gps.lat, lon: gps.lon, acc: gps.acc, spd: gps.spd, head: gps.head,
      place: includePlace ? ((meta.place!=null? meta.place : (placeNameEl? placeNameEl.value : '')) || '') : '',
      note:  (meta.note!=null? meta.note : (placeMemoEl? placeMemoEl.value : '')) || ''
    };
    window.eventLog.push(rec); saveEventLog();
    try{ if(geoStatus) geoStatus.textContent='記録: ' + kind; }catch(e){}
  };

  // CSV 出力ヘッダ（place, note を含める）
  function exportCSV(){
    if(!window.eventLog.length){
      try{ if(geoStatus) geoStatus.textContent='
  <div id="csvMinutesBox" style="margin:8px 0;display:flex;gap:8px;align-items:center;">
    <label for="csvMinutes" style="font-size:0.95em;">CSV出力期間（分）</label>
    <input id="csvMinutes" type="number" min="1" step="1" value="3" style="width:6em;">
    <span style="font-size:0.85em;color:#9aa4b2;">※デフォルト3分／この分数以内のデータだけを書き出します</span>
  </div>

CSV対象のイベントがありません'; }catch(e){}
      return;
    }
    const header = ['timeISO','epoch','type','level','spa','p','lat','lon','acc','spd','head','place','note','observer'];
    const lines = [header.join(',')].concat(
      window.eventLog.map(r => header.map(k => (r[k]==null? '' : r[k])).join(','))
    );
    const blob = new Blob([lines.join('\\n')], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = window.makeCsvFilename();
    document.body.appendChild(a); a.click(); setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    try{ if(geoStatus) geoStatus.textContent='CSVを書き出しました'; }catch(e){}
  }
  btnExportCSV && btnExportCSV.addEventListener('click', exportCSV);

  // 手動記録ボタン：現在の表示（kpi）からSPA/p取得
  btnManualLog && btnManualLog.addEventListener('click', ()=>{
    const spa = parseFloat((document.getElementById('kpiSPA')||{}).textContent||'');
    const p   = parseFloat((document.getElementById('kpiP')||{}).textContent||'');
    window.logEvent('manual', { spa: Number.isFinite(spa)? spa:null, p: Number.isFinite(p)? p:null });
  });

  // 自動記録：SPAレベル >= しきい値（デフォルト2.1）を1秒ごと監視、10秒デバウンス
  function readCurrentSPA(){
    const spa = parseFloat((document.getElementById('kpiSPA')||{}).textContent||'');
    const p   = parseFloat((document.getElementById('kpiP')||{}).textContent||'');
    const level = Number.isFinite(spa) ? (spa*2.44) : null;
    return { level, spa: Number.isFinite(spa)? spa:null, p: Number.isFinite(p)? p:null };
  }
  let lastAuto = 0;
  function autoTick(){
  if(!(chkAutoSpaLog && chkAutoSpaLog.checked)) return;
  const th = parseFloat(inpSpaLevelThresh?.value || '2.1');
  const target = (document.getElementById('selSpaLevelTarget')?.value || 'C');

  const lv = (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM());
  let curVal = null;
  if(target === 'A') curVal = lv.A;
  else if(target === 'B') curVal = lv.B;
  else curVal = lv.C;

  if(curVal!=null && curVal >= th){
    const now = Date.now();
    if(now - lastAuto > 10000){ // 10s debounce
      lastAuto = now;
      window.logEvent('level', { 
        levelA: lv.A,
        levelB: lv.B,
        levelC: lv.C,
        note: (logNote?.value || '')
      });
    }
  }
});
      }
    }
  }
  setInterval(autoTick, 1000);
})();
</script>
<script>
(function(){
  // --- Ensure level & place are always present in records ---
  function formatJST(ts){
    const d = new Date(ts);
    return d.toLocaleString('ja-JP', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
  }
  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  // wrap push to fill level/time/place if missing
  (function enforceRecordShape(){
    const _push = Array.prototype.push;
    if(!window.eventLog) window.eventLog = [];
    // monkey patch eventLog.push to normalize records
    if(!window.eventLog.__patched){
      window.eventLog.push = function(){
        for(let i=0;i<arguments.length;i++){
          const r = arguments[i] || {};
          // time: JST string
          if(!r.timeISO){ r.timeISO = formatJST(Date.now()); }
          // level: prefer given; else compute from spa; else compute from UI
          if(typeof r.level !== 'number' || !isFinite(r.level)){
            let spa = r.spa;
            if(!(typeof spa === 'number' && isFinite(spa))){
              const sTxt = (document.getElementById('kpiSPA')||{}).textContent || '';
              const s = parseFloat(sTxt);
              spa = isFinite(s) ? s : null;
            }
            if(typeof spa === 'number' && isFinite(spa)) r.level = spa * 2.44;
          }
          // place: respect checkbox; fallback to input
          if(!('place' in r)){
            const include = !!(chkIncludePlace && chkIncludePlace.checked);
            r.place = include ? ((placeNameEl && placeNameEl.value) || '') : '';
          }
          if(!('observer' in r) || typeof r.observer !== 'string'){
            var _obEl = document.getElementById('observerName');
            r.observer = _obEl && _obEl.value ? String(_obEl.value).trim() : (r.observer || '');
          }
          arguments[i] = r;
        }
        return _push.apply(this, arguments);
      };
      Object.defineProperty(window.eventLog, '__patched', {value:true});
    }
  })();

  // --- Replace the CSV export button to output only [place, time, level] ---
  const btn = document.getElementById('btnExportCSV');
  if(btn){
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn); // remove old listeners
    clone.addEventListener('click', function(){
      if(!window.eventLog || !window.eventLog.length){
        const geoStatus = document.getElementById('geoStatus');
        if(geoStatus) geoStatus.textContent = 'CSV対象のイベントがありません';
        return;
      }
      const header = ['place','time','level','observer'];
      const rows = [header.join(',')].concat(
        window.eventLog.map(r => {
          const place = r.place != null ? String(r.place) : '';
          const time  = r.timeISO != null ? String(r.timeISO) : formatJST(Date.now());
          const lvl   = (typeof r.level === 'number' && isFinite(r.level)) ? r.level.toFixed(2) : '';
          return [place, time, lvl].join(',');
        })
      );
      const blob = new Blob([rows.join('\\n')], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_events_place_time_level_jst.csv';
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
      const geoStatus = document.getElementById('geoStatus');
      if(geoStatus) geoStatus.textContent = 'CSV（場所,時間,レベル）を出力しました';
    });
  }
})();
</script>
<script>
// --- Robust CSV exporter: UTF-8 BOM, CRLF, columns = 場所,日付,時間,SPAレベルA,B,C ---
(function(){
  function csvEscape(v){
    if(v==null) return '';
    const s = String(v);
    return /[",\r\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  }
  function ensureTimeString(rec){
    if (rec && rec.timeISO) return String(rec.timeISO); // "YYYY/MM/DD HH:MM:SS" (JST)
    const d = new Date();
    return d.toLocaleString('ja-JP', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
  }
  function splitDateTime(jstStr){
    const m = String(jstStr).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/);
    if (m) return { date: m[1], time: m[2] };
    const parts = String(jstStr).split(' ');
    return { date: parts[0] || '', time: parts[1] || '' };
  }
  function ensurePlace(rec){
    if (rec && rec.place!=null) return String(rec.place);
    const el = document.getElementById('placeName');
    const chk = document.getElementById('chkIncludePlace');
    return (chk && chk.checked && el) ? String(el.value||'') : '';
  }
  function fmtA(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtB(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtC(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(2) : ''; }

  const btn = document.getElementById('btnExportCSV');
  if(btn){
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(){
      const geoStatus = document.getElementById('geoStatus');
      const log = (window.eventLog && window.eventLog.length) ? window.eventLog.slice() : [];

      if(!log.length){
        // fallback: export one row of current snapshot (not saved to storage)
        const place = ensurePlace({});
        const jst   = ensureTimeString({});
        const dt = splitDateTime(jst);
        const lv = (typeof readLatchedLevelsFromDOM === 'function') ? (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM()) : {A:'',B:'',C:''};
        const a = fmtA(lv.A), b = fmtB(lv.B), c = fmtC(lv.C);
        const header = ['場所','観測者','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
        const lines = [header.join(',')];
        lines.push([csvEscape(place), csvEscape(dt.date), csvEscape(dt.time), csvEscape(a), csvEscape(b), csvEscape(c)].join(','));
        const csvStr = '\ufeff' + lines.join('\r\n');
        const blob = new Blob([csvStr], {type:'text/csv;charset=utf-8;'});
        const aTag = document.createElement('a');
        aTag.href = URL.createObjectURL(blob);
        aTag.download = 'spa_場所_日付_時間_レベルABC.csv';
        document.body.appendChild(aTag); aTag.click();
        setTimeout(()=>{ URL.revokeObjectURL(aTag.href); aTag.remove(); }, 100);
        if(geoStatus) geoStatus.textContent = 'CSV（救済）現在値1行を出力しました';
        return;
      }

      log.sort((a,b)=>{
        const ea = (typeof a.epoch==='number')? a.epoch : 0;
        const eb = (typeof b.epoch==='number')? b.epoch : 0;
        return ea - eb;
      });

      const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
      const lines = [header.join(',')];
      for(const r of log){
        const place = ensurePlace(r);
        const jst   = ensureTimeString(r);
        const dt = splitDateTime(jst);
        const a = fmtA(r.levelA);
        const b = fmtB(r.levelB);
        const c = fmtC(r.levelC);
        lines.push([csvEscape(place), csvEscape(dt.date), csvEscape(dt.time), csvEscape(a), csvEscape(b), csvEscape(c)].join(','));
      }
      const csvStr = '\ufeff' + lines.join('\r\n');
      const blob = new Blob([csvStr], {type:'text/csv;charset=utf-8;'});
      const aTag = document.createElement('a');
      aTag.href = URL.createObjectURL(blob);
      aTag.download = 'spa_場所_日付_時間_レベルABC.csv';
      document.body.appendChild(aTag); aTag.click();
      setTimeout(()=>{ URL.revokeObjectURL(aTag.href); aTag.remove(); }, 100);
      if(geoStatus) geoStatus.textContent = 'CSV（場所,日付,時間,SPAレベルA,B,C）を出力しました';
    });
  }
})();
</script>
<script>
// ---- Fresh-start stabilizer (prevents first-frame jump after long idle open) ----
(function(){
  function safe(fn){ try{ fn && fn(); }catch(e){} }
  function clearCanvas(id){
    var c = document.getElementById(id);
    if(!c) return;
    var ctx = c.getContext && c.getContext('2d');
    if(!ctx) return;
    ctx.clearRect(0,0,c.width||c.clientWidth||0,c.height||c.clientHeight||0);
  }
  function resetArrays(names){
    names.forEach(function(n){
      if(window[n] && Array.isArray(window[n])){
        window[n].length = 0;
      }
    });
  }
  function resetNumbers(names){
    names.forEach(function(n){
      if(n in window){
        try{ window[n]=0; }catch(e){}
      }
    });
  }
  function prepareFreshStart(){
    // establish a time base and warm-up horizon
    var now = (performance && performance.now)? performance.now() : Date.now();
    window.__spaFreshStartAt = now;
    window.__spaWarmupUntil = now + 250; // ignore oversized dt for first 250ms
    window.__spaStartSeq = (window.__spaStartSeq||0) + 1;

    // likely data arrays used in this app (reset if present)
    resetArrays(['spaVals','pVals','meanBuf','mean5s','ydata','ybuf','ringP','ringSPA']);
    resetNumbers(['x','writeIdx','accum','lastTs','lastDrawTs','drift','driftEst']);

    // clear KPI text (optional)
    safe(function(){ var el=document.getElementById('kpiSPA'); if(el) el.textContent=''; });
    safe(function(){ var el=document.getElementById('kpiP'); if(el) el.textContent=''; });
    safe(function(){ var el=document.getElementById('kpiLevel'); if(el) el.textContent=''; });

    // clear canvases
    clearCanvas('bg');
    clearCanvas('fg');

    // resume audio if needed
    safe(function(){
      var AC = window.AC || window.audioCtx || window.audioContext;
      if(AC && AC.state==='suspended' && AC.resume) { AC.resume(); }
    });
  }

  // Clamp large dt on first frames by wrapping requestAnimationFrame during warm-up
  (function(){
    var _raf = window.requestAnimationFrame;
    if(!_raf || window.__rafPatched) return;
    window.requestAnimationFrame = function(cb){
      return _raf(function(t){
        try{
          if(window.__spaWarmupUntil && performance && performance.now){
            var now = performance.now();
            // expose a hint that downstream code may use
            window.__spaIsWarming = now < window.__spaWarmupUntil;
          }
        }catch(e){}
        cb(t);
      });
    };
    window.__rafPatched = true;
  })();

  // Ensure our reset runs BEFORE the app's own click handler using capture phase
  var btn = document.getElementById('btnStart');
  if(btn){
    btn.addEventListener('click', function(evt){
      prepareFreshStart();
    }, true); // capture
  }
})();
</script>
<script>
// --- FINAL OVERRIDE: 音量＆周波数を「どれだけ大きく超えたか」で動的制御 ---
// 既存の dynBeep(kind) を上書きします。既存呼び出し側の変更は不要です。
(function(){
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  // レベル推定（優先順：引数mag -> lastDisplay.level -> |z| -> 1）
  function estimateLevel(kind, mag){
    if(typeof mag === 'number' && isFinite(mag)) return mag;
    // UIラッチ表示から
    if(window.lastDisplay && typeof lastDisplay.level === 'number' && isFinite(lastDisplay.level)){
      return lastDisplay.level;
    }
    // 生zが取れるなら使う（2σ用に直感的）
    try{
      const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
      if(st && typeof st.mean==='number' && typeof st.std==='number' && st.std>0){
        const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
        const z = Math.abs((x - st.mean)/st.std);
        return z * 2.44; // zをレベル相当に換算（おおよそ）
      }
    }catch(e){}
    return 1; // フォールバック
  }
  window.dynBeep = function(kind="th", mag){
    if(!audioReady || (selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}
    const now = AC.currentTime;
    const mast = masterGain;

    // 基準周波数（従来：閾値880Hz / 2σ1320Hz）
    const base = (kind==="z") ? 1320 : 880;

    // レベル推定 → 音量・周波数スケーリング
    const level = estimateLevel(kind, mag);              // 例：1.3, 2.5, 4.0...
    const vol   = clamp(0.06 + (level-1)*0.10, 0.05, 1); // レベル1→0.06、以後+0.10/レベル（上限1）
    const freq  = base + (level-1)*160;                  // レベル1→base、以後+160Hz/レベル

    // オシレータを短いエンベロープで鳴らす（kindで長さ微調整）
    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(freq, now);

    // クリックノイズを抑えるエンベロープ（AR）
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    o.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);
  };
})();
</script>
<script>
// --- FINAL OVERRIDE (UI sliders & defaults) ---
(function(){
  function $(id){ return document.getElementById(id); }
  const volScaleEl = $('rngVolScale');
  const pitchStepEl = $('rngPitchStep');
  const volMaxEl = $('rngVolMax');
  const lblVolScale = $('lblVolScale');
  const lblPitchStep = $('lblPitchStep');
  const lblVolMax = $('lblVolMax');

  function updLabels(){
    if(lblVolScale && volScaleEl) lblVolScale.textContent = (parseFloat(volScaleEl.value)||1).toFixed(2) + '×';
    if(lblPitchStep && pitchStepEl) lblPitchStep.textContent = (parseFloat(pitchStepEl.value)||160).toFixed(0) + ' Hz/level';
    if(lblVolMax && volMaxEl) lblVolMax.textContent = (parseFloat(volMaxEl.value)||1).toFixed(2);
  }
  ['input','change'].forEach(ev=>{
    volScaleEl && volScaleEl.addEventListener(ev, updLabels);
    pitchStepEl && pitchStepEl.addEventListener(ev, updLabels);
    volMaxEl && volMaxEl.addEventListener(ev, updLabels);
  });
  updLabels();

  // デフォルト値の設定：ドリフト α=0.05、SPAレベル自動記録=1.5
  try{
    const alphaInput = document.getElementById('inpAlpha') || document.querySelector('[name="alpha"]');
    if(alphaInput){ alphaInput.value = 0.05; }
    if(window.alpha !== undefined){ window.alpha = 0.05; }
  }catch(e){}
  try{
    const autoLevel = document.getElementById('inpSpaLevelThresh');
    if(autoLevel){ autoLevel.value = 1.5; }
    if(window.autoRecordLevel !== undefined){ window.autoRecordLevel = 1.5; }
  }catch(e){}

  // しきい値が内部で参照される型なら、保存/反映フローがあれば呼ぶ
  try{
    if(typeof applyParams==='function') applyParams();
  }catch(e){}

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function estimateLevel(kind, mag){
    if(typeof mag === 'number' && isFinite(mag)) return mag;
    if(window.lastDisplay && typeof lastDisplay.level === 'number' && isFinite(lastDisplay.level)){
      return lastDisplay.level;
    }
    try{
      const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
      if(st && typeof st.mean==='number' && typeof st.std==='number' && st.std>0){
        const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
        const z = Math.abs((x - st.mean)/st.std);
        return z * 2.44;
      }
    }catch(e){}
    return 1;
  }

  // dynBeepを再オーバーライドしてスライダの値を反映
  window.dynBeep = function(kind="th", mag){
    if(!window.audioReady || (window.selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}
    const now = AC.currentTime;
    const mast = masterGain;

    const base = (kind==="z") ? 1320 : 880;
    const level = estimateLevel(kind, mag);

    const volBase = 0.06 + (level-1)*0.10;
    const volScale = volScaleEl ? parseFloat(volScaleEl.value) || 1 : 1;
    const volMax = volMaxEl ? parseFloat(volMaxEl.value) || 1 : 1;
    const vol = clamp(volBase * volScale, 0.01, volMax);

    const step = pitchStepEl ? parseFloat(pitchStepEl.value) || 160 : 160;
    const freq = base + (level-1)*step;

    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;

    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    o.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);
  };
})();
</script>
<style>
#fxFlash{
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at center, rgba(255,60,60,0.35), rgba(255,0,0,0.0) 60%);
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease-out;
  mix-blend-mode: screen;
  z-index: 9999;
}
</style>
<style>
#fxFlash.white { background: rgba(255,255,255,0.9) !important; mix-blend-mode: screen; }
#fxFlash.red { background: radial-gradient(ellipse at center, rgba(255,60,60,0.35), rgba(255,0,0,0.0) 60%) !important; }
#fxFlash.blue { background: radial-gradient(ellipse at center, rgba(60,160,255,0.35), rgba(0,80,255,0.0) 60%) !important; }
</style>
<div id="fxFlash"></div>
<script>
// --- FINAL OVERRIDE: 強演出プリセット & フラッシュ/バイブ連動 ---
(function(){
  function $(id){ return document.getElementById(id); }
  const volScaleEl = $('rngVolScale');
  const pitchStepEl = $('rngPitchStep');
  const volMaxEl = $('rngVolMax');
  const btnQuiet = $('btnPresetQuiet');
  const btnNormal = $('btnPresetNormal');
  const btnStrong = $('btnPresetStrong');
  const flash = $('fxFlash');
  const chkStrongFX = $('chkStrongFX');

  function applyPreset(name){
    if(name==='quiet'){
      if(volScaleEl) volScaleEl.value = 0.6;
      if(pitchStepEl) pitchStepEl.value = 120;
      if(volMaxEl) volMaxEl.value = 0.4;
    }else if(name==='normal'){
      if(volScaleEl) volScaleEl.value = 1.0;
      if(pitchStepEl) pitchStepEl.value = 160;
      if(volMaxEl) volMaxEl.value = 1.0;
    }else if(name==='strong'){
      if(volScaleEl) volScaleEl.value = 2.2;
      if(pitchStepEl) pitchStepEl.value = 300;
      if(volMaxEl) volMaxEl.value = 1.0;
      if(chkStrongFX) chkStrongFX.checked = true;
    }
    // fire input events so labels update if any
    ['input','change'].forEach(ev=>{
      volScaleEl && volScaleEl.dispatchEvent(new Event(ev));
      pitchStepEl && pitchStepEl.dispatchEvent(new Event(ev));
      volMaxEl && volMaxEl.dispatchEvent(new Event(ev));
    });
  }
  btnQuiet && btnQuiet.addEventListener('click', ()=>applyPreset('quiet'));
  btnNormal && btnNormal.addEventListener('click', ()=>applyPreset('normal'));
  btnStrong && btnStrong.addEventListener('click', ()=>applyPreset('strong'));

  // Visual flash & vibration helpers
  function flashFX(intensity){
    if(!flash || !chkStrongFX || !chkStrongFX.checked) return;
    const op = Math.max(0, Math.min(1, 0.25 + intensity*0.15)); // 0.25..1.0
    flash.style.opacity = op;
    setTimeout(()=>{ flash.style.opacity = 0; }, 180);
  }
  function vibrateFX(level){
    if(!chkStrongFX || !chkStrongFX.checked) return;
    if(navigator.vibrate){
      const ms = Math.max(40, Math.min(400, 60 + (level-1)*80));
      /*tone-vibe disabled*/ false && navigator.vibrate(ms);
    }
  }

  // Hook into dynBeep to add FX & (optionally) burst for strong events
  const origDynBeep = window.dynBeep;
  window.dynBeep = function(kind="th", mag){
    // call original to play sound (which reads sliders)
    try{ origDynBeep && origDynBeep(kind, mag); }catch(e){}

    // estimate "level" for FX intensity
    let level = 1;
    try{
      if(typeof mag === 'number' && isFinite(mag)) level = mag;
      else if(window.lastDisplay && isFinite(lastDisplay.level)) level = lastDisplay.level;
      else{
        const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
        if(st && st.std>0){
          const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
          const z = Math.abs((x - st.mean)/st.std);
          level = z*2.44;
        }
      }
    }catch(e){}

    // strong FX
    flashFX(level);
    vibrateFX(level);

    // burst beeps for very strong events
    if(chkStrongFX && chkStrongFX.checked && level >= 3){
      setTimeout(()=>{ try{ origDynBeep && origDynBeep(kind, level+0.4); }catch(e){} }, 90);
      setTimeout(()=>{ try{ origDynBeep && origDynBeep(kind, level+0.7); }catch(e){} }, 190);
    }
  };

  // Optional: auto-apply "強演出" on load for convenience
  // applyPreset('strong'); // uncomment if you want default strong
})();
</script>
<script>
// --- FINAL OVERRIDE: 波形/歪み/フラッシュ様式 + 自動強演出ON ---
(function(){
  function $(id){ return document.getElementById(id); }
  const selWave = $('selWave');
  const rngDist = $('rngDist');
  const lblDist = $('lblDist');
  const selFlash = $('selFlash');
  const chkAutoStrong = $('chkAutoStrong');
  const flash = $('fxFlash');

  function updDistLabel(){
    if(lblDist && rngDist) lblDist.textContent = String(parseInt(rngDist.value||'0',10));
  }
  ['input','change'].forEach(ev=>{ rngDist && rngDist.addEventListener(ev, updDistLabel); });
  updDistLabel();

  // Remember settings
  const LSKEY = 'spa_strong_preset_settings';
  function saveSettings(){
    try{
      const data = {
        wave: selWave ? selWave.value : 'sine',
        dist: rngDist ? parseInt(rngDist.value||'0',10) : 0,
        flash: selFlash ? selFlash.value : 'red',
        autoStrong: chkAutoStrong ? !!chkAutoStrong.checked : true
      };
      localStorage.setItem(LSKEY, JSON.stringify(data));
    }catch(e){}
  }
  function loadSettings(){
    try{
      const raw = localStorage.getItem(LSKEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      if(selWave && data.wave) selWave.value = data.wave;
      if(rngDist && (data.dist!==undefined)) rngDist.value = data.dist;
      if(selFlash && data.flash) selFlash.value = data.flash;
      if(chkAutoStrong && (data.autoStrong!==undefined)) chkAutoStrong.checked = !!data.autoStrong;
      updDistLabel();
    }catch(e){}
  }
  ['input','change'].forEach(ev=>{
    selWave && selWave.addEventListener(ev, saveSettings);
    rngDist && rngDist.addEventListener(ev, saveSettings);
    selFlash && selFlash.addEventListener(ev, saveSettings);
    chkAutoStrong && chkAutoStrong.addEventListener(ev, saveSettings);
  });
  loadSettings();

  // Apply strong preset automatically if opted-in
  try{
    if(chkAutoStrong && chkAutoStrong.checked && typeof applyPreset==='function'){
      // apply strong after UI is ready
      setTimeout(()=>{ try{ applyPreset('strong'); }catch(e){} }, 50);
    }
  }catch(e){}

  // Extend dynBeep to use waveform + optional waveshaper distortion
  const origDynBeep = window.dynBeep;
  window.dynBeep = function(kind="th", mag){
    if(!window.audioReady || (window.selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}

    // Let the existing dynBeep compute timing, volume, and base connections,
    // but we'll rebuild the audio graph here to insert waveshaper.
    // We'll replicate the volume & pitch calculations by temporarily calling the original and intercepting not possible,
    // so we redo minimal logic by reading UI from previous override:
    const now = AC.currentTime;
    const mast = masterGain;

    // Reuse estimateLevel logic if available:
    let level = 1;
    try{
      if(typeof mag === 'number' && isFinite(mag)) level = mag;
      else if(window.lastDisplay && isFinite(lastDisplay.level)) level = lastDisplay.level;
      else{
        const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
        if(st && st.std>0){
          const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
          const z = Math.abs((x - st.mean)/st.std);
          level = z*2.44;
        }
      }
    }catch(e){}

    const base = (kind==="z") ? 1320 : 880;
    // Sliders from previous UI (if exist)
    const volScaleEl = document.getElementById('rngVolScale');
    const pitchStepEl = document.getElementById('rngPitchStep');
    const volMaxEl = document.getElementById('rngVolMax');
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    const volBase = 0.06 + (level-1)*0.10;
    const volScale = volScaleEl ? parseFloat(volScaleEl.value) || 1 : 1;
    const volMax = volMaxEl ? parseFloat(volMaxEl.value) || 1 : 1;
    const vol = clamp(volBase * volScale, 0.01, volMax);
    const step = pitchStepEl ? parseFloat(pitchStepEl.value) || 160 : 160;
    const freq = base + (level-1)*step;
    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;

    // Build audio graph: Oscillator -> [WaveShaper?] -> Gain -> master
    const o = AC.createOscillator();
    o.type = (selWave && selWave.value) || 'sine';
    o.frequency.setValueAtTime(freq, now);

    let nodeChainOut = o;
    // optional distortion
    const distAmt = rngDist ? parseInt(rngDist.value||'0',10) : 0;
    if(distAmt > 0){
      const ws = AC.createWaveShaper();
      // create simple curve: arctangent style
      const n=1024; const curve = new Float32Array(n);
      const k = distAmt; // 0..40
      for(let i=0;i<n;i++){
        const x = (i/(n-1))*2 - 1;
        curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
      }
      ws.curve = curve; ws.oversample = '4x';
      nodeChainOut.connect(ws); nodeChainOut = ws;
    }

    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    nodeChainOut.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);

    // Flash style
    if(flash){
      flash.classList.remove('white','red','blue');
      const style = (selFlash && selFlash.value) || 'red';
      flash.classList.add(style);
      const opBase = (style==='white') ? 0.7 : 0.25;
      const op = Math.max(0, Math.min(1, opBase + level*0.15));
      flash.style.opacity = op;
      setTimeout(()=>{ flash.style.opacity = 0; }, (style==='white') ? 120 : 180);
    }

    // Burst for strong events remains handled by prior override (if any)
    try{
      const chkStrongFX = document.getElementById('chkStrongFX');
      if(chkStrongFX && chkStrongFX.checked && level >= 3){
        setTimeout(()=>{ try{ window.dynBeep && origDynBeep && origDynBeep(kind, level+0.4); }catch(e){} }, 90);
        setTimeout(()=>{ try{ window.dynBeep && origDynBeep && origDynBeep(kind, level+0.7); }catch(e){} }, 190);
      }
    }catch(e){}
  };
})();
</script>
<script>
(function(){
  const btnTestFlash = document.getElementById('btnTestFlash');
  const flash = document.getElementById('fxFlash');
  const selFlash = document.getElementById('selFlash');
  if(btnTestFlash && flash){
    btnTestFlash.addEventListener('click', ()=>{
      flash.classList.remove('white','red','blue');
      const style = (selFlash && selFlash.value) || 'red';
      flash.classList.add(style);
      flash.style.opacity = 1;
      setTimeout(()=>{ flash.style.opacity = 0; }, (style==='white')?120:180);
    });
  }
})();
</script>
<script>
// ===== Sampling Rate Slider Wiring =====
(function(){
  // Desired global hooks:
  // - A function stopScan() that clears intervals/RAF if present
  // - A function startScan() that starts the main loop using current interval
  // If they don't exist, we will wrap the existing loop.

  // Expose/initialize globals
  window.__spaSamplingHz = 10;         // default Hz
  window.__spaSamplingIntervalMs = 100;
  window.__spaScanTimer = null;
  window.__spaUseRAF = false; // set true if your main loop uses requestAnimationFrame

  // Find slider
  const rate = document.getElementById('samplingRate');
  const lblHz = document.getElementById('samplingRateLabel');
  const lblMs = document.getElementById('samplingIntervalLabel');

  function applySampling(hz){
    hz = Math.max(5, Math.min(120, Math.round(hz)));
    window.__spaSamplingHz = hz;
    window.__spaSamplingIntervalMs = Math.max(1, Math.round(1000 / hz));
    if (lblHz) lblHz.textContent = hz.toString();
    if (lblMs) lblMs.textContent = window.__spaSamplingIntervalMs.toString();
  }
  applySampling(rate ? parseInt(rate.value,10) : 10);

  // Try to detect existing scan loop starter
  // We look for a start button with id-like 'btnScan' or text 'スキャン実行' to hook restart
  function restartScanIfRunning(){
    // If timer running, restart with new interval
    if (window.__spaScanTimer){
      if (window.__spaUseRAF && window.cancelAnimationFrame){
        cancelAnimationFrame(window.__spaScanTimer);
      }else{
        clearInterval(window.__spaScanTimer);
      }
      window.__spaScanTimer = null;
      if (typeof window.__spaMainStep === 'function'){
        // Start with new interval
        if (window.__spaUseRAF){
          const loop = ()=>{ window.__spaMainStep(); window.__spaScanTimer = requestAnimationFrame(loop); };
          window.__spaScanTimer = requestAnimationFrame(loop);
        }else{
          window.__spaScanTimer = setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
        }
      }
    }
  }

  if (rate){
    rate.addEventListener('input', (e)=>{
      applySampling(parseInt(rate.value,10));
      restartScanIfRunning();
    });
  }

  // ---- Wrapping existing logic ----
  // We attempt to hook the app's main step function. If your code calls setInterval(mainStep, X),
  // define window.__spaMainStep = mainStep and use our timer.
  // Below, we monkey-patch setInterval to capture main loop if possible (best-effort, non-breaking).
  (function(){
    const _setInterval = window.setInterval;
    window.setInterval = function(fn, ms, ...rest){
      // Heuristic: if interval is between 10ms and 1000ms and function name looks like a main loop,
      // we capture it as __spaMainStep and drive it ourselves.
      try{
        if (typeof fn === 'function' && ms >= 10 && ms <= 1000 && !window.__spaMainStep){
          // Register main step
          window.__spaMainStep = fn;
          // Use our own interval based on slider
          const t = _setInterval(()=>{}, 1); clearInterval(t); // noop to keep behavior similar
          // Start our timer if not already
          if (!window.__spaScanTimer){
            applySampling(window.__spaSamplingHz);
            window.__spaScanTimer = _setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
          }
          return window.__spaScanTimer;
        }
      }catch(e){ /* fallthrough */ }
      return _setInterval(fn, ms, ...rest);
    };
    const _clearInterval = window.clearInterval;
    window.clearInterval = function(id){
      if (id === window.__spaScanTimer){
        window.__spaScanTimer = null;
      }
      return _clearInterval(id);
    };
  })();

  // Optional: expose manual controls
  window.__spaStopScan = function(){
    if (window.__spaScanTimer){
      if (window.__spaUseRAF && window.cancelAnimationFrame){
        cancelAnimationFrame(window.__spaScanTimer);
      }else{
        clearInterval(window.__spaScanTimer);
      }
      window.__spaScanTimer = null;
    }
  };
  window.__spaStartScan = function(){
    if (window.__spaScanTimer || typeof window.__spaMainStep !== 'function') return;
    if (window.__spaUseRAF){
      const loop = ()=>{ window.__spaMainStep(); window.__spaScanTimer = requestAnimationFrame(loop); };
      window.__spaScanTimer = requestAnimationFrame(loop);
    }else{
      window.__spaScanTimer = setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
    }
  };

  // If your app uses requestAnimationFrame, set:
  // window.__spaUseRAF = true; before calling __spaStartScan().
})();
</script>
<script>
// ===== Windowed/Cumulative Frequency (超え率) =====
(function(){
  // 状態
  window.__freqMode = 'window'; // 'cumulative' or 'window'
  window.__freqWindowSec = 1;
  window.__freqNowLabel = null;
  window.__freqModeLabel = null;
  window.__freqResetBtn = null;
  window.__freqWindowBuf = []; // booleans
  window.__freqBufMax = 0;
  window.__freqBufIdx = 0;
  window.__freqBufFilled = 0;
  window.__freqK_cum = 0;
  window.__freqN_cum = 0;
  window.__spaCurrentStepOver = false;

  function el(id){ return document.getElementById(id); }

  function updateBufSize(){
    const hz = window.__spaSamplingHz || 10;
    window.__freqBufMax = Math.max(1, Math.round(hz * window.__freqWindowSec));
    if (window.__freqWindowBuf.length !== window.__freqBufMax){
      window.__freqWindowBuf = new Array(window.__freqBufMax).fill(false);
      window.__freqBufIdx = 0;
      window.__freqBufFilled = 0;
    }
  }

  function resetWindow(){
    window.__freqWindowBuf.fill(false);
    window.__freqBufIdx = 0;
    window.__freqBufFilled = 0;
  }
  function resetCumulative(){
    window.__freqK_cum = 0;
    window.__freqN_cum = 0;
  }

  // UI wiring
  function initUI(){
    window.__freqNowLabel = el('freqNowLabel');
    window.__freqModeLabel = el('freqModeLabel');
    window.__freqResetBtn = el('freqResetBtn');
    const winSec = el('freqWindowSec');
    const radios = document.querySelectorAll('input[name="freqMode"]');

    radios.forEach(r=>{
      r.addEventListener('change', ()=>{
        window.__freqMode = r.value;
        if (window.__freqModeLabel) window.__freqModeLabel.textContent = (r.value === 'window') ? '区間' : '累積';
        if (r.value === 'window'){ resetWindow(); }
        else { resetCumulative(); }
        updateBufSize();
      });
    });

    if (winSec){
      winSec.addEventListener('change', ()=>{
        const v = Math.max(1, Math.min(30, parseInt(winSec.value||'1',10)));
        winSec.value = v;
        window.__freqWindowSec = v;
        updateBufSize();
      });
    }

    if (window.__freqResetBtn){
      window.__freqResetBtn.addEventListener('click', ()=>{
        if (window.__freqMode === 'window') resetWindow(); else resetCumulative();
      });
    }

    // 初期設定
    window.__freqMode = 'window';
    window.__freqWindowSec = Math.max(1, parseInt(winSec ? winSec.value : '1', 10));
    if (window.__freqModeLabel) window.__freqModeLabel.textContent = '区間';
    updateBufSize();
  }

  // 統合：各ステップ前後でフラグを扱うため、__spaMainStep をラップ
  function installStepWrapper(){
    if (typeof window.__spaMainStep !== 'function') return;
    if (window.__wrappedMainStep) return; // double wrap防止
    const orig = window.__spaMainStep;
    window.__wrappedMainStep = function(){
      // ステップ開始：今ステップの超過フラグをfalseでクリア
      window.__spaCurrentStepOver = false;
      // 実行
      orig();
      // 実行後：超過フラグを集計
      // 区間モード
      if (window.__freqMode === 'window'){
        if (window.__freqBufMax <= 0) updateBufSize();
        const idx = window.__freqBufIdx;
        const prev = window.__freqWindowBuf[idx] ? 1 : 0;
        const cur = window.__spaCurrentStepOver ? 1 : 0;
        window.__freqWindowBuf[idx] = !!window.__spaCurrentStepOver;
        window.__freqBufIdx = (idx + 1) % window.__freqBufMax;
        if (window.__freqBufFilled < window.__freqBufMax) window.__freqBufFilled++;

        // 計算
        let K = 0;
        // 小規模なので単純合計
        for (let i=0;i<window.__freqBufFilled;i++){ if (window.__freqWindowBuf[i]) K++; }
        const N = window.__freqBufFilled;
        const p = (K + 1) / (N + 2);
        if (window.__freqNowLabel) window.__freqNowLabel.textContent = (p*100).toFixed(2) + '%';
      } else {
        // 累積モード
        window.__freqN_cum++;
        if (window.__spaCurrentStepOver) window.__freqK_cum++;
        const p = (window.__freqK_cum + 1) / (window.__freqN_cum + 2);
        if (window.__freqNowLabel) window.__freqNowLabel.textContent = (p*100).toFixed(2) + '%';
      }
    };
    window.__spaMainStep = window.__wrappedMainStep;
  }

  // dynBeep / logEvent をパッチして、そのステップで超過が起きたらフラグを立てる
  function patchTriggers(){
    const markOver = ()=>{ window.__spaCurrentStepOver = true; };
    // dynBeep
    const _dynBeep = window.dynBeep;
    window.dynBeep = function(){ try{ markOver(); }catch(e){}; return _dynBeep ? _dynBeep.apply(this, arguments) : undefined; };
    // logEvent
    const _logEvent = window.logEvent;
    window.logEvent = function(){ try{ markOver(); }catch(e){}; return _logEvent ? _logEvent.apply(this, arguments) : undefined; };
  }

  window.addEventListener('load', function(){
    try{
      initUI();
      patchTriggers();
      // install step wrapper once main step is known
      const intv = setInterval(()=>{
        if (typeof window.__spaMainStep === 'function'){
          installStepWrapper();
          clearInterval(intv);
        }
      }, 100);
    }catch(e){ console.warn('freq wiring error', e); }
  });
})();
</script>
<script>
(function(){
  if (window.__spa_csv_patch_applied2__) return;
  window.__spa_csv_patch_applied2__ = true;

  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function readLatchedLevelsFromDOM(){
    function numText(el){
      if(!el) return null;
      const t = (el.textContent||'').replace(/[^\d\.\-]/g,'');
      const v = parseFloat(t);
      return Number.isFinite(v) ? v : null;
    }
    return {
      A: numText(document.getElementById('kpiLevelA')),
      B: numText(document.getElementById('kpiLevelB')),
      C: numText(document.getElementById('kpiLevelC')),
    };
  }
  if (typeof window.getLatchedLevels !== 'function'){
    window.getLatchedLevels = function(){ return readLatchedLevelsFromDOM(); };
  }
  function loadEventLog(){
    try{ const s = localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; }
  }
  function saveEventLog(){ try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){} }
  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

  const originalLogEvent = window.logEvent;
  window.logEvent = function(kind, meta={}){
    let lv=null;
    try{ lv=(typeof window.getLatchedLevels==='function')?window.getLatchedLevels():readLatchedLevelsFromDOM(); }
    catch(_){ lv=readLatchedLevelsFromDOM(); }
    const levelA = Number.isFinite(meta.levelA) ? meta.levelA : (Number.isFinite(lv?.A) ? lv.A : null);
    const levelB = Number.isFinite(meta.levelB) ? meta.levelB : (Number.isFinite(lv?.B) ? lv.B : null);
    const levelC = Number.isFinite(meta.levelC) ? meta.levelC : (Number.isFinite(lv?.C) ? lv.C : null);
    const spa = Number.isFinite(meta.spa) ? meta.spa : null;
    const levelFallback = Number.isFinite(spa) ? spa*2.44 : (levelC ?? levelB ?? levelA ?? null);
    const get = id => document.getElementById(id);
    const includePlace = !!(get('chkIncludePlace')?.checked ?? true);
    const attachLoc = !!(get('chkAttachLoc')?.checked);
    const placeName = includePlace ? ((meta.place ?? (get('placeName')?.value) ?? '') + '') : '';
    const gps = attachLoc ? (function(){
      const pf = v => { const x=parseFloat(v); return Number.isFinite(x)?x:null; };
      return {lat:pf(get('geoLat')?.value), lon:pf(get('geoLon')?.value), acc:pf(get('geoAcc')?.value),
              spd:pf(get('geoSpd')?.value), head:pf(get('geoHead')?.value)};
    })() : {lat:null,lon:null,acc:null,spd:null,head:null};
    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind,
      levelA, levelB, levelC,
      level: Number.isFinite(meta.level) ? meta.level : levelFallback,
      spa: spa,
      p: Number.isFinite(meta.p) ? meta.p : null,
      ...gps,
      place: placeName,
      note:  (meta.note ?? (get('placeMemo')?.value) ?? '') + ''
    ,
    observer: (typeof meta.observer === 'string' ? meta.observer : '')};
    try{ if (typeof originalLogEvent === 'function') originalLogEvent(kind, meta); }catch(_){}
    try{ window.eventLog.push(rec); saveEventLog(); }catch(_){}
    const st = get('geoStatus'); if(st) st.textContent = '記録: ' + kind + '（' + rec.timeISO + '）';
  };

  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSV(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ const st=document.getElementById('geoStatus'); if(st) st.textContent='CSV対象のイベントがありません'; return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC))
      ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    const st=document.getElementById('geoStatus'); if(st) st.textContent='CSVを書き出しました（場所,日付,時間,ABC）';
  }

  function bindClick(el){
    if(!el) return;
    el.style.pointerEvents = 'auto';
    el.style.userSelect = 'auto';
    el.removeAttribute('disabled');
    ['click','mousedown','touchstart'].forEach(evt=>{
      el.addEventListener(evt, function(ev){
        ev.preventDefault(); ev.stopPropagation();
        try{ exportCSV(); }catch(e){ console.error(e); }
      }, {passive:false});
    });
  }

  function install(){
    // 1) id優先
    var el = document.getElementById('btnExportCSV');
    if(el){ bindClick(el); }
    // 2) ラベル探索（"イベントCSV"を含むボタン/リンク）
    var nodes = Array.from(document.querySelectorAll('button, a, [role="button"]'));
    nodes.filter(n => (n.textContent||'').indexOf('イベントCSV') >= 0).forEach(bindClick);
    // 3) 予備ボタンを隣に注入
    if(el && !document.getElementById('btnExportCSV_fallback')){
      var fb = document.createElement('button');
      fb.id = 'btnExportCSV_fallback';
      fb.textContent = 'イベントCSV（予備）';
      fb.style.marginLeft = '8px';
      el.insertAdjacentElement('afterend', fb);
      bindClick(fb);
    }
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', install); } else { install(); }
})();
</script>
<script>
(function(){
  if (window.__spa_csv_hotfix__) return; window.__spa_csv_hotfix__=true;

  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSV(){
    try{
      const log = Array.isArray(window.eventLog) ? window.eventLog : [];
      if(!log.length){ const st=document.getElementById('geoStatus'); if(st) st.textContent='CSV対象のイベントがありません'; return; }
      const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
      const rows = [header.join(',')];
      for(const r of log){
        const dt = splitDateTime(r.timeISO ?? '');
        rows.push([
          csvEscape(r.place ?? ''),
          csvEscape(dt.date),
          csvEscape(dt.time),
          csvEscape(fmtA(r.levelA)),
          csvEscape(fmtB(r.levelB)),
          csvEscape(fmtC(r.levelC))
        ].join(','));
      }
      const bom = new Uint8Array([0xEF,0xBB,0xBF]);
      const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_events_place_date_time_ABC.csv';
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
      const st=document.getElementById('geoStatus'); if(st) st.textContent='CSVを書き出しました（場所,日付,時間,ABC）';
    }catch(e){ console.error(e); }
  }

  function safeBind(el){
    if(!el || el.__csv_hotfix_bound) return;
    el.__csv_hotfix_bound = true;
    el.addEventListener('click', function(){
      // 1) 保存前のKPIテキストを控える
      const Ael = document.getElementById('kpiLevelA');
      const Bel = document.getElementById('kpiLevelB');
      const Cel = document.getElementById('kpiLevelC');
      const oldA = Ael ? Ael.textContent : null;
      const oldB = Bel ? Bel.textContent : null;
      const oldC = Cel ? Cel.textContent : null;

      // 2) CSVを書き出し
      exportCSV();

      // 3) 万一どこかで消えた場合に備えて元に戻す
      setTimeout(()=>{
        if(Ael && (!Ael.textContent || Ael.textContent.trim()==='—') && oldA) Ael.textContent = oldA;
        if(Bel && (!Bel.textContent || Bel.textContent.trim()==='—') && oldB) Bel.textContent = oldB;
        if(Cel && (!Cel.textContent || Cel.textContent.trim()==='—') && oldC) Cel.textContent = oldC;
      }, 50);
    }, {capture:false});
  }

  function init(){
    const idBtn = document.getElementById('btnExportCSV');
    if(idBtn) safeBind(idBtn);
    // テキストで検索（イベントCSV）— UIそのまま対応
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0)
      .forEach(safeBind);
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>
<script>
(function(){
  if (window.__spa_recorder_v3__) return; window.__spa_recorder_v3__=true;

  // ---------- helpers ----------
  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function numFromText(el){
    if(!el) return null;
    const t = (el.textContent||'').replace(/[^\d\.\-]/g,'');
    const v = parseFloat(t);
    return Number.isFinite(v) ? v : null;
  }
  function getLevels(){
    return {
      A: numFromText(document.getElementById('kpiLevelA')),
      B: numFromText(document.getElementById('kpiLevelB')),
      C: numFromText(document.getElementById('kpiLevelC')),
    };
  }
  function readGPS(){
    const g = id => document.getElementById(id);
    const pf = v => { const x = parseFloat(v); return Number.isFinite(x)?x:null; };
    return {
      lat: pf(g('geoLat')?.value), lon: pf(g('geoLon')?.value),
      acc: pf(g('geoAcc')?.value), spd: pf(g('geoSpd')?.value), head: pf(g('geoHead')?.value),
    };
  }
  function placeEnabled(){ const c = document.getElementById('chkIncludePlace'); return (c==null) ? true : !!c.checked; }
  function attachLoc(){ const c = document.getElementById('chkAttachLoc'); return !!(c&&c.checked); }
  function placeName(){ return placeEnabled() ? ((document.getElementById('placeName')?.value)||'') : ''; }
  function memoText(){ return (document.getElementById('placeMemo')?.value)||''; }
  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }

  // ---------- persistent log ----------
  function loadEventLog(){
    try{ const s=localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; }
  }
  function saveEventLog(){
    try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){}
  }
  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

  // ---------- unified logEvent ----------
  const prevLogEvent = window.logEvent;
  window.logEvent = function(kind, meta={}){
    // merge with current latched levels
    const lv = getLevels();
    const levelA = Number.isFinite(meta.levelA) ? meta.levelA : lv.A;
    const levelB = Number.isFinite(meta.levelB) ? meta.levelB : lv.B;
    const levelC = Number.isFinite(meta.levelC) ? meta.levelC : lv.C;
    const spa = Number.isFinite(meta.spa) ? meta.spa : null;
    const levelFallback = Number.isFinite(spa) ? spa*2.44 : (Number.isFinite(levelC)?levelC:Number.isFinite(levelB)?levelB:Number.isFinite(levelA)?levelA:null);

    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind||'manual',
      levelA: Number.isFinite(levelA)?levelA:null,
      levelB: Number.isFinite(levelB)?levelB:null,
      levelC: Number.isFinite(levelC)?levelC:null,
      level: Number.isFinite(meta.level)? meta.level : levelFallback,
      spa: spa,
      p: Number.isFinite(meta.p) ? meta.p : null,
      ...(attachLoc()? readGPS(): {lat:null,lon:null,acc:null,spd:null,head:null}),
      place: placeName(),
      note: (meta.note ?? memoText())+''
    ,
    observer: (typeof meta.observer === 'string' ? meta.observer : '')};

    // push our log first (so even if the original throws, we keep data)
    try{ window.eventLog.push(rec); saveEventLog(); }catch(e){ console.warn('log push failed', e); }
    try{ if (typeof prevLogEvent === 'function') prevLogEvent(kind, meta); }catch(e){ console.warn('orig logEvent error', e); }
    status('記録: ' + rec.type + '（' + rec.timeISO + '）');
    return rec;
  };

  // ---------- bind "今を記録" (by id and by label) ----------
  function bindRecordNow(){
    const bind = el => { if(!el || el.__rec_v3) return; el.__rec_v3=true; el.addEventListener('click', ()=>{ window.logEvent('manual', {}); }); };
    const idBtn = document.getElementById('btnRecordNow'); if(idBtn) bind(idBtn);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('今を記録')>=0).forEach(bind);
  }

  // ---------- optional auto logging (uses existing checkbox/threshold/target if present) ----------
  (function(){
    const chk = document.getElementById('chkAutoSpaLog');
    const inpTh = document.getElementById('inpSpaLevelThresh');
    const targetSel = document.getElementById('selSpaLevelTarget');
    let last = 0;
    function tick(){
      if(!(chk&&chk.checked)) return;
      const th = parseFloat(inpTh?.value||'2.1');
      const t = (targetSel?.value||'C');
      const lv = getLevels();
      const cur = t==='A'?lv.A : t==='B'?lv.B : lv.C;
      const now = Date.now();
      if(Number.isFinite(cur) && cur>=th && now-last>10000){
        last = now;
        window.logEvent('level', { levelA: lv.A, levelB: lv.B, levelC: lv.C });
      }
    }
    setInterval(tick, 1000);
  })();

  // ---------- CSV export (single handler) ----------
  function exportCSV(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    // time-window filter
    try{
      var box = document.getElementById('csvMinutes');
      var mins = box ? parseFloat(box.value) : 3;
      if(!isFinite(mins) || mins<=0) mins = 3;
      var cutoff = Date.now() - Math.round(mins*60*1000);
      // filter in place
      if(Array.isArray(window.eventLog) && window.eventLog.length){
        window.eventLog = window.eventLog.filter(r => (r && typeof r.epoch==='number' ? r.epoch : 0) >= cutoff);
      }
    }catch(e){}
    if(!log.length){ status('CSV対象のイベントがありません'); return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
    function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
    function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
    function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
    function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([ csvEscape(r.place??''), csvEscape(r.observer??''), csvEscape(dt.date), csvEscape(dt.time),
                  csvEscape(fmtA(r.levelA)), csvEscape(fmtB(r.levelB)), csvEscape(fmtC(r.levelC)) ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    status('CSVを書き出しました（場所,日付,時間,ABC）');
  }
  function bindCSV(){
    const attach = el => { if(!el || el.__csv_v3) return; el.__csv_v3=true; el.addEventListener('click', exportCSV, {capture:false}); };
    const idBtn = document.getElementById('btnExportCSV'); if(idBtn) attach(idBtn);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0).forEach(attach);
  }

  function init(){ bindRecordNow(); bindCSV(); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>
<script>
(function(){
  if (window.__spa_singleclick_v4__) return; window.__spa_singleclick_v4__=true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSVOnce(){
    // cooldown guard
    const now = Date.now();
    if (window.__spa_csv_cooldown && now - window.__spa_csv_cooldown < 800) return;
    window.__spa_csv_cooldown = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    status('CSVを書き出しました（場所,日付,時間,ABC）');
  }

  function cleanBind(el){
    if(!el) return;
    // Replace with a clean clone to drop existing listeners (prevents multi-download)
    const clone = el.cloneNode(true);
    // keep id and text as-is; replace in DOM
    el.replaceWith(clone);
    // Bind a single click handler; do not stop propagation; once:false (guard handles repeats)
    clone.addEventListener('click', exportCSVOnce, {capture:false});
    return clone;
  }

  function init(){
    let attached = 0;
    // 1) id-based
    const idBtn = document.getElementById('btnExportCSV');
    if(idBtn){ cleanBind(idBtn); attached++; }
    // 2) label-based
    const nodes = Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0);
    nodes.forEach(n => { cleanBind(n); attached++; });
    // 3) ensure at least one exists: if none, create a minimal fallback next to geoStatus
    if(attached===0){
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      cleanBind(fb);
    }
  }

  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>
<script>
(function(){
  // Add Lon/Lat to CSV and set default auto-target to A, keeping UI unchanged.
  if (window.__spa_latlon_v5__) return; window.__spa_latlon_v5__ = true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSVOnceV5(){
    // Unified single-click guard (works alongside existing one)
    const now = Date.now();
    if (window.__spa_csv_cooldown2 && now - window.__spa_csv_cooldown2 < 800) return;
    window.__spa_csv_cooldown2 = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    // Header with Lon/Lat
    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    status('CSVを書き出しました（場所,日付,時間,経度,緯度,ABC）');
  }

  function bind(){
    // Default auto target = A (set value on load; user can still change later)
    const sel = document.getElementById('selSpaLevelTarget');
    if (sel) sel.value = 'A';

    // Attach our CSV handler in the capture phase so it runs first.
    const buttons = new Set();
    const byId = document.getElementById('btnExportCSV'); if(byId) buttons.add(byId);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0)
      .forEach(n => buttons.add(n));
    buttons.forEach(el => {
      if (!el || el.__latlon_v5_bound) return;
      el.__latlon_v5_bound = true;
      el.addEventListener('click', function(ev){
        try{ exportCSVOnceV5(); }catch(e){ console.error(e); }
      }, {capture:true});
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bind); } else { bind(); }
})();
</script>
<script>
(function(){
  if (window.__spa_csv_v6__) return; window.__spa_csv_v6__=true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSV_v6(){
    const now = Date.now();
    if (window.__spa_csv_cooldown_v6 && now - window.__spa_csv_cooldown_v6 < 800) return;
    window.__spa_csv_cooldown_v6 = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    status('CSVを書き出しました（場所,日付,時間,経度,緯度,ABC）');
  }

  function cleanBindOne(el, primary){
    const clone = el.cloneNode(true);
    el.replaceWith(clone);
    if (primary){
      clone.addEventListener('click', exportCSV_v6, {capture:false});
    } else {
      // Non-primary buttons just proxy to primary click for visual consistency
      clone.addEventListener('click', function(){ try{ primary.click(); }catch(_){} }, {capture:false});
    }
    return clone;
  }

  function init(){
    // 1) Default auto target = A
    const sel = document.getElementById('selSpaLevelTarget');
    if (sel) sel.value = 'A';

    // 2) Collect all CSV-like buttons
    const candidates = [];
    const idBtn = document.getElementById('btnExportCSV');
    if (idBtn) candidates.push(idBtn);
    document.querySelectorAll('button, a, [role="button"]').forEach(n => {
      const t = (n.textContent||'').trim();
      if (t.indexOf('イベントCSV')>=0) candidates.push(n);
    });

    // 3) Choose primary (prefer id button), clone to remove all old listeners, bind only our handler
    if (candidates.length===0){
      // Fallback: create one
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      cleanBindOne(fb, fb); // primary is itself
      return;
    }
    // Deduplicate nodes
    const uniq = Array.from(new Set(candidates));
    const primary = idBtn && uniq.includes(idBtn) ? idBtn : uniq[0];
    const primaryCloned = cleanBindOne(primary, true);

    // Rebind others to proxy the primary
    uniq.forEach(n => {
      if (n===primary) return;
      cleanBindOne(n, primaryCloned);
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>
<script>
(function(){
  if (window.__spa_csv_v7_dedup__) return; window.__spa_csv_v7_dedup__=true;

  // ---- Helpers (robust fallbacks) ----
  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function numText(el){ if(!el) return null; const t=(el.textContent||'').replace(/[^\d\.\-]/g,''); const v=parseFloat(t); return Number.isFinite(v)?v:null; }
  function getLevels(){
    try{ if (typeof window.getLatchedLevels==='function') return window.getLatchedLevels(); }catch(_){}
    return {
      A: numText(document.getElementById('kpiLevelA')),
      B: numText(document.getElementById('kpiLevelB')),
      C: numText(document.getElementById('kpiLevelC')),
    };
  }
  function readGPS(){
    const g = id => document.getElementById(id);
    const pf = v => { const x=parseFloat(v); return Number.isFinite(x)?x:null; };
    return {
      lat: pf(g('geoLat')?.value), lon: pf(g('geoLon')?.value),
      acc: pf(g('geoAcc')?.value), spd: pf(g('geoSpd')?.value), head: pf(g('geoHead')?.value),
    };
  }
  function placeEnabled(){ const c = document.getElementById('chkIncludePlace'); return (c==null) ? true : !!c.checked; }
  function attachLoc(){ const c = document.getElementById('chkAttachLoc'); return !!(c&&c.checked); }
  function placeName(){ return placeEnabled() ? ((document.getElementById('placeName')?.value)||'') : ''; }
  function memoText(){ return (document.getElementById('placeMemo')?.value)||''; }
  function loadEventLog(){ try{ const s=localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; } }
  function saveEventLog(){ try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){ } }

  // ---- De-duplicating logEvent wrapper ----
  function eq(a,b){ return (a===b) || (Number.isFinite(a)&&Number.isFinite(b)&&Math.abs(a-b)<1e-9); }
  function sameRec(r1,r2){
    if(!r1||!r2) return false;
    return (r1.type===r2.type)
       && (r1.place===r2.place)
       && (r1.timeISO===r2.timeISO)
       && eq(r1.levelA, r2.levelA)
       && eq(r1.levelB, r2.levelB)
       && eq(r1.levelC, r2.levelC)
       && eq(r1.lon, r2.lon)
       && eq(r1.lat, r2.lat);
  }

  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();
  const prevLogEvent = window.logEvent;

  window.logEvent = function(kind, meta={}){
    const beforeLen = Array.isArray(window.eventLog) ? window.eventLog.length : 0;
    let prevLast = beforeLen ? window.eventLog[beforeLen-1] : null;

    // Call original first (if any)
    let origResult = null;
    try{ if (typeof prevLogEvent==='function') origResult = prevLogEvent(kind, meta); }catch(_){}

    // Ensure eventLog array exists
    window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

    const afterLen = window.eventLog.length;
    if (afterLen > beforeLen){
      // A new record was added by original handler -> fill missing fields + dedup with previous
      let last = window.eventLog[afterLen-1];
      // Fill
      const lv = getLevels();
      if(!Number.isFinite(last.levelA)) last.levelA = Number.isFinite(lv.A)? lv.A : last.levelA;
      if(!Number.isFinite(last.levelB)) last.levelB = Number.isFinite(lv.B)? lv.B : last.levelB;
      if(!Number.isFinite(last.levelC)) last.levelC = Number.isFinite(lv.C)? lv.C : last.levelC;
      if(!('place' in last)) last.place = placeName();
      if(attachLoc()){
        const gps = readGPS();
        if(!Number.isFinite(last.lon)) last.lon = gps.lon;
        if(!Number.isFinite(last.lat)) last.lat = gps.lat;
      }
      if(!last.timeISO) last.timeISO = nowJST();
      // Dedup with second last
      if (beforeLen && sameRec(last, prevLast)){
        window.eventLog.splice(afterLen-1, 1); // remove duplicate
      }
      saveEventLog();
      return last;
    } else {
      // Original didn't push -> we push our own record
      const lv = getLevels();
      const gps = attachLoc()? readGPS() : {lat:null,lon:null,acc:null,spd:null,head:null};
      const rec = {
        timeISO: nowJST(),
        epoch: Date.now(),
        type: kind||'manual',
        levelA: Number.isFinite(meta.levelA) ? meta.levelA : (Number.isFinite(lv.A)? lv.A : null),
        levelB: Number.isFinite(meta.levelB) ? meta.levelB : (Number.isFinite(lv.B)? lv.B : null),
        levelC: Number.isFinite(meta.levelC) ? meta.levelC : (Number.isFinite(lv.C)? lv.C : null),
        spa: Number.isFinite(meta.spa) ? meta.spa : null,
        p: Number.isFinite(meta.p) ? meta.p : null,
        ...gps,
        place: placeName(),
        note: (meta.note ?? memoText()) + ''
      ,
    observer: (typeof meta.observer === 'string' ? meta.observer : '')};
      rec.level = Number.isFinite(meta.level) ? meta.level : (Number.isFinite(rec.levelC)? rec.levelC : (Number.isFinite(rec.levelB)? rec.levelB : rec.levelA));

      if (!sameRec(rec, prevLast)){
        window.eventLog.push(rec);
        saveEventLog();
        status('記録: ' + rec.type + '（' + rec.timeISO + '）');
      }
      return rec;
    }
  };

  // ---- CSV export: unique rows only (lon/lat included) ----
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSV_v7_unique(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    const seen = new Set();
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      const key = [
        r.place ?? '', dt.date, dt.time,
        Number.isFinite(r.lon)? r.lon.toFixed(6):'',
        Number.isFinite(r.lat)? r.lat.toFixed(6):'',
        Number.isFinite(r.levelA)? r.levelA.toFixed(1):'',
        Number.isFinite(r.levelB)? r.levelB.toFixed(1):'',
        Number.isFinite(r.levelC)? r.levelC.toFixed(2):'',
      ].join('|');
      if (seen.has(key)) continue;
      seen.add(key);
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 1500);
    status('CSVを書き出しました（重複排除）');
  }

  // ---- Rebind CSV button to our unique exporter (single click) ----
  function bindUniqueCSV(){
    const candidates = [];
    const idBtn = document.getElementById('btnExportCSV');
    if (idBtn) candidates.push(idBtn);
    document.querySelectorAll('button, a, [role="button"]').forEach(n => {
      const t = (n.textContent||'').trim();
      if (t.indexOf('イベントCSV')>=0) candidates.push(n);
    });
    const uniq = Array.from(new Set(candidates));
    if (uniq.length===0){
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      uniq.push(fb);
    }
    // Choose primary
    const primary = idBtn && uniq.includes(idBtn) ? idBtn : uniq[0];
    // Clone + bind (remove old listeners)
    const primClone = primary.cloneNode(true);
    primary.replaceWith(primClone);
    primClone.addEventListener('click', (ev)=>{
      const now = Date.now();
      if (window.__spa_csv_cooldown_v7 && now - window.__spa_csv_cooldown_v7 < 800) return;
      window.__spa_csv_cooldown_v7 = now;
      exportCSV_v7_unique();
    }, {capture:false});

    // Other buttons proxy to primary
    uniq.forEach(n => {
      if (n===primary) return;
      const c = n.cloneNode(true);
      n.replaceWith(c);
      c.addEventListener('click', ()=>{ primClone.click(); }, {capture:false});
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bindUniqueCSV); } else { bindUniqueCSV(); }
})();
</script>
<!-- Added by assistant: default strong FX ON and test vibrate wiring -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  const chk = document.getElementById('chkStrongFX');
  if (chk) chk.checked = true;
  const btnV = document.getElementById('btnTestVibrate');
  if (btnV) btnV.addEventListener('click', function(){
    if ('vibrate' in navigator) /*tone-vibe disabled*/ false && navigator.vibrate([60,80,60]);
  });
  const btnF = document.getElementById('btnTestFlash');
  if (btnF) btnF.addEventListener('click', function(){
    if (document.getElementById('chkStrongFX')?.checked && 'vibrate' in navigator) {
      /*tone-vibe disabled*/ false && navigator.vibrate([60,80,60]);
    }
  });
});
</script>
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('./service-worker.js').catch(function(e){console.warn('SW failed', e);});
  });
}
</script>
<script>
(function(){
  function getCsvMinutes(){
    var el = document.getElementById('csvMinutes');
    var v = parseInt(el && el.value || '3', 10);
    if(!isFinite(v) || v<=0) v = 3;
    return v;
  }
  // 共有ヘルパ：配列を分数でフィルタ（timestamp: ISO or epoch allowed）
  window.filterByRecentMinutes = function(records){
    try{
      var mins = getCsvMinutes();
      var now = Date.now();
      var cutoff = now - mins*60*1000;
      function tsToMs(t){
        if(t==null) return 0;
        if (typeof t === 'number') return t;
        var d = new Date(t); 
        var ms = d.getTime();
        return isFinite(ms) ? ms : 0;
      }
      return (records||[]).filter(function(rec){
        var t = rec.timestamp || rec.time || rec.ts || rec.date || rec.createdAt;
        if (typeof rec === 'string') {
          // CSV row string fallback: pass through (cannot parse)
          return true;
        }
        return tsToMs(t) >= cutoff;
      });
    }catch(e){
      console.warn('filterByRecentMinutes failed', e);
      return records||[];
    }
  };
})();
</script>
<script>
(function(){
  // 強制的に Blob を作る前にフィルタを適用するようにラップ
  function wrapCsvDownloader(){
    function wrapFn(fn){
      return function(data){
        if (window.filterByRecentMinutes && data) {
          try { data = window.filterByRecentMinutes(data); } catch(e){ console.warn(e); }
        }
        return fn.call(this, data);
      };
    }
    if (typeof window.exportCsv === 'function'){
      window.exportCsv = wrapFn(window.exportCsv);
    }
    if (typeof window.exportEventsCsv === 'function'){
      window.exportEventsCsv = wrapFn(window.exportEventsCsv);
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wrapCsvDownloader);
  }else{
    wrapCsvDownloader();
  }
})();
</script>
<script>
(function(){
  const kpiLevelAEl = document.getElementById('kpiLevelA');
  const kpiLevelAmaxEl = document.getElementById('kpiLevelAmax');
  const lblCperiod = document.getElementById('lblCperiod');
  const lblElapsed = document.getElementById('lblElapsed');
  const inpAvgSecC = document.getElementById('inpAvgSecC');

  let peakALevel = null;
  const startTs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

  function fmtSecToMMSS(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec/60); const s = sec%60;
    return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
  }

  function updateCPeriodLabel(){
    if (!lblCperiod) return;
    let secC = 0;
    if (inpAvgSecC) {
      const v = parseFloat(inpAvgSecC.value);
      secC = (isFinite(v) && v >= 0) ? v : 0;
    }
    lblCperiod.textContent = (secC > 0) ? (secC.toFixed(1) + ' 秒') : '全時間（累積）';
  }

  // Update A-peak and labels every 200ms (robust even if internal variables are unknown)
  setInterval(function(){
    // read current A value from DOM if available
    if (kpiLevelAEl) {
      const t = (kpiLevelAEl.textContent || '').replace(/[^\d\.\-]/g, '');
      const v = parseFloat(t);
      if (isFinite(v)) {
        if (peakALevel === null || v > peakALevel) peakALevel = v;
      }
    }
    // write peak
    if (kpiLevelAmaxEl) {
      if (typeof peakALevel === 'number' && isFinite(peakALevel)) {
        const vv = Math.round(peakALevel * 10) / 10;
        kpiLevelAmaxEl.textContent = vv.toFixed(1);
      } else {
        kpiLevelAmaxEl.textContent = '—';
      }
    }
    // elapsed
    if (lblElapsed) {
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const elapsedSec = (now - startTs)/1000;
      lblElapsed.textContent = fmtSecToMMSS(elapsedSec);
    }
  }, 200);

  // initialize & react to changes
  updateCPeriodLabel();
  if (inpAvgSecC) {
    inpAvgSecC.addEventListener('input', updateCPeriodLabel);
    inpAvgSecC.addEventListener('change', updateCPeriodLabel);
  }

  // Try to hook into existing reset() if present
  try {
    const origReset = window.reset;
    if (typeof origReset === 'function') {
      window.reset = function(){
        const r = origReset.apply(this, arguments);
        peakALevel = null;
        if (kpiLevelAmaxEl) kpiLevelAmaxEl.textContent = '—';
        return r;
      };
    }
  } catch(e){ /* ignore */ }
})();
</script>
<style>
/* Safe relayout mini styles */
#controlDock2 {
  display: grid;
  gap: 8px;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  align-items: start;
  padding: 8px 10px;
  margin: 8px 6px;
  border: 1px solid #e3e3e3;
  border-radius: 12px;
}
#controlDock2 .dock-title{
  grid-column: 1/-1;
  font-weight: 600;
  opacity: .8;
}
.safely-hidden { display: none !important; }
</style>
<script>
document.addEventListener('DOMContentLoaded', function(){
  function $all(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
  function makeDock(){
    var dock = document.getElementById('controlDock2');
    if (dock) return dock;
    dock = document.createElement('div');
    dock.id = 'controlDock2';
    var host = document.getElementById('controlArea') || document.getElementById('controls') || document.getElementById('kpiArea') || document.body;
    var title = document.createElement('div');
    title.className = 'dock-title';
    title.textContent = 'コントロール';
    dock.appendChild(title);
    host.insertBefore(dock, host.firstChild);
    return dock;
  }

  // Helper: find .item whose .badge exactly matches text
  function findItemsByBadge(text){
    var found = [];
    $all('.item').forEach(function(it){
      var b = it.querySelector('.badge');
      if (b && (b.textContent||'').trim() === text) found.push(it);
    });
    return found;
  }

  // 1) CSV出力期間が複数ある場合は先頭以外を非表示
  var csvItems = findItemsByBadge('CSV出力期間（分）');
  for (var i=1;i<csvItems.length;i++){
    csvItems[i].classList.add('safely-hidden');
  }

  // 2) KPIの「p値（区間平均）」「SPA値（区間平均）」「SPAレベル（区間平均×2.44）」を非表示
  ['p値（区間平均）','SPA値（区間平均）','SPAレベル（区間平均×2.44）'].forEach(function(lbl){
    findItemsByBadge(lbl).forEach(function(it){ it.classList.add('safely-hidden'); });
  });

  // 3) 「超え率モード」「p値」をコントロール枠へ移動
  var dock = makeDock();
  ['超え率モード','p値'].forEach(function(lbl){
    var its = findItemsByBadge(lbl);
    if (its.length){
      dock.appendChild(its[0]); // move first found
    }
  });
});
</script>
<script>
(function(){
  function readCsvMinutes(){
    var nodes = Array.prototype.slice.call(document.querySelectorAll('#csvMinutes'));
    for (var i=0;i<nodes.length;i++){
      var v = parseFloat(nodes[i].value);
      if (isFinite(v) && v > 0) return v;
    }
    return 3;
  }
  function ensureStatus(msg){
    var el = document.getElementById('geoStatus');
    if(el) el.textContent = msg;
  }
  function splitDateTime(jst){
    // jst like "2025-08-30T12:34:56+09:00" or ISO string; be tolerant
    try{
      var d = new Date(jst);
      if (isNaN(+d)) return {date:String(jst), time:''};
      // format to JST components
      var yyyy = d.getFullYear();
      var mm = String(d.getMonth()+1).padStart(2,'0');
      var dd = String(d.getDate()).padStart(2,'0');
      var HH = String(d.getHours()).padStart(2,'0');
      var MM = String(d.getMinutes()).padStart(2,'0');
      var SS = String(d.getSeconds()).padStart(2,'0');
      return {date: yyyy+'-'+mm+'-'+dd, time: HH+':'+MM+':'+SS};
    }catch(e){
      return {date:String(jst), time:''};
    }
  }
  function fmtA(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtB(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtC(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(2) : ''; }
  function fmtNum(n){ return (typeof n==='number' && isFinite(n)) ? n : ''; }

  function exportCSV_filtered_legacy(){
    try{
      var log = Array.isArray(window.eventLog) ? window.eventLog.slice() : [];
      if(!log.length){ ensureStatus('CSV対象のイベントがありません'); return; }

      var mins = readCsvMinutes();
      var cutoff = Date.now() - Math.round(mins*60*1000);
      var filt = log.filter(function(r){
        var e = (r && typeof r.epoch === 'number') ? r.epoch : 0;
        return e >= cutoff;
      });
      if(!filt.length){ ensureStatus('指定期間内のイベントがありません（'+mins+'分）'); return; }

      
      // --- De-duplicate rows (same epoch≈, place, levels, lat, lon) ---
      var seen = new Set();
      var dedup = [];
      for (var i=0;i<filt.length;i++){
        var r = filt[i] || {};
        var epochBucket = (typeof r.epoch==='number') ? Math.round(r.epoch/500) : 0; // 0.5秒単位で丸め
        var k = [
          epochBucket,
          r.place||'',
          Number.isFinite(r.levelA)? r.levelA.toFixed(3) : '',
          Number.isFinite(r.levelB)? r.levelB.toFixed(3) : '',
          Number.isFinite(r.levelC)? r.levelC.toFixed(3) : '',
          Number.isFinite(r.lat)? r.lat.toFixed(6) : '',
          Number.isFinite(r.lon)? r.lon.toFixed(6) : ''
        ].join('|');
        if(!seen.has(k)){ seen.add(k); dedup.push(r); }
      }
      filt = dedup;
    // --- Legacy layout ---
      var header = ['場所','観測者','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC','緯度','経度'];
      var lines = [header.join(',')];
      for (var i=0;i<filt.length;i++){
        var r = filt[i];
        var dt = splitDateTime(r.timeISO || '');
        var row = [ (r.place ? String(r.place).replace(/"/g,'""') : ''), (r.observer ? String(r.observer).replace(/\"/g,'\"\"') : ''), dt.date, dt.time,
          fmtA(r.levelA), fmtB(r.levelB), fmtC(r.levelC),
          fmtNum(r.lat), fmtNum(r.lon)
        ].map(function(x){
          var s = (x==null) ? '' : String(x);
          return /[",\r\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
        }).join(',');
        lines.push(row);
      }
      var csvStr = '\ufeff' + lines.join('\r\n');
      var blob = new Blob([csvStr], {type:'text/csv;charset=utf-8;'});
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_場所_日付_時間_レベルABC_緯度経度.csv';
      document.body.appendChild(a); a.click();
      setTimeout(function(){ URL.revokeObjectURL(a.href); a.remove(); }, 120);
      ensureStatus('CSV（従来レイアウト, 直近'+mins+'分, '+filt.length+'件）を書き出しました');
    }catch(e){
      console.error(e);
      ensureStatus('CSV書き出しでエラー: ' + e);
    }
  }

  function rebindExporter(){
    var targets = Array.prototype.slice.call(document.querySelectorAll('#btnExportCSV, button, a, [role="button"]'))
      .filter(function(n){ return (n.textContent||'').indexOf('イベントCSV')>=0; });
    targets.forEach(function(n){
      var c = n.cloneNode(true);
      n.parentNode.replaceChild(c, n);
      c.addEventListener('click', exportCSV_filtered_legacy, {capture:false});
    });
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', rebindExporter);
  }else{
    rebindExporter();
  }
})();
</script>
<!-- === SPA CSV/Observer hard override (v3) === -->
<script>
(function(){
  function getObserver(){
    var el = document.getElementById('observerName');
    var v = el && el.value ? String(el.value).trim() : '';
    return v;
  }
  function ensureWhiteBG(){
    try{
      var el = document.getElementById('observerName');
      if(!el) return;
      var v = getObserver();
      if(v){
        el.style.background = '#ffffff';
        el.style.color = '#000000';
      }else{
        el.style.background = '';
        el.style.color = '';
      }
    }catch(e){}
  }
  // reflect on input
  try{
    var el = document.getElementById('observerName');
    if(el){
      el.addEventListener('input', ensureWhiteBG);
      el.addEventListener('change', ensureWhiteBG);
      setTimeout(ensureWhiteBG, 100);
    }
  }catch(e){}

  // Normalize eventLog container
  if(!window.eventLog) window.eventLog = [];
  // Monkey-patch push to always inject observer
  (function(){
    var _push = Array.prototype.push;
    if(!window.eventLog.__observer_patched){
      window.eventLog.push = function(){
        for(var i=0;i<arguments.length;i++){
          var r = arguments[i] || {};
          if(!('observer' in r) || !r.observer){
            r.observer = getObserver();
          }
          arguments[i] = r;
        }
        return _push.apply(this, arguments);
      };
      Object.defineProperty(window.eventLog, '__observer_patched', {value:true});
    }
  })();

  // Replace CSV export to include 'observer' and respect csvMinutes if present
  (function(){
    var oldBtn = document.getElementById('btnExportCSV');
    if(!oldBtn) return;
    var clone = oldBtn.cloneNode(true);
    oldBtn.parentNode.replaceChild(clone, oldBtn); // remove old listeners
    clone.addEventListener('click', function(){
      // Take a snapshot and optionally filter by minutes
      var arr = Array.isArray(window.eventLog) ? window.eventLog.slice() : [];
      try{
        var minBox = document.getElementById('csvMinutes');
        var minVal = minBox ? parseFloat(minBox.value) : NaN;
        if(isFinite(minVal) && minVal > 0){
          var cutoff = Date.now() - Math.round(minVal*60*1000);
          arr = arr.filter(function(r){ return (r && typeof r.epoch==='number' && r.epoch >= cutoff); });
        }
      }catch(e){}
      if(!arr.length){
        var gs = document.getElementById('geoStatus');
        if(gs) gs.textContent = 'CSV対象のイベントがありません';
        return;
      }
      // Ensure each record has observer
      for(var j=0;j<arr.length;j++){
        if(!arr[j].observer) arr[j].observer = getObserver();
      }
      var header = ['timeISO','epoch','type','level','spa','p','lat','lon','acc','spd','head','place','note','observer'];
      var lines = [header.join(',')];
      for(var i=0;i<arr.length;i++){
        var r = arr[i] || {};
        lines.push(header.map(function(k){ return (r[k]==null ? '' : r[k]); }).join(','));
      }
      var blob = new Blob(['\ufeff' + lines.join('\r\n')], {type:'text/csv;charset=utf-8'});
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_events_with_observer.csv';
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){ URL.revokeObjectURL(a.href); a.remove(); }, 120);
      var gs = document.getElementById('geoStatus');
      if(gs) gs.textContent = 'CSVを書き出しました（観測者を含む）';
    });
  })();

  // Optional: add a tiny "ログ初期化" button to clear old records without observer
  (function(){
    var p = document.getElementById('gpsPanel');
    if(!p) return;
    var b = document.createElement('button');
    b.textContent = 'ログ初期化';
    b.className = 'btn danger';
    b.style.marginLeft = '8px';
    b.addEventListener('click', function(){
      try{
        window.eventLog.length = 0;
        localStorage.removeItem('spa_event_log'); // if used
        var gs = document.getElementById('geoStatus');
        if(gs) gs.textContent = 'イベントログを初期化しました';
      }catch(e){}
    });
    var row = p.querySelector('.row');
    if(row) row.appendChild(b);
  })();
})();
</script>
<!-- === /override === -->
<!-- === SPA UI Patch: Controls Drawer + Warmup (seconds) === -->
<style id="spa-ui-patch-style">
/* ---- Controls drawer ---- */
#controlsCard {
  position: fixed;
  top: 14px;
  right: 14px;
  width: 360px;
  max-height: calc(100vh - 28px);
  overflow: auto;
  transform: translateX(120%);        /* 初期は隠す */
  transition: transform .28s ease;
  z-index: 9998;
}
#controlsCard.is-open {
  transform: translateX(0);           /* 表示 */
}
/* 一旦1カラム化して左のモニタを広く使う */
@media (min-width: 1px){
  .wrap{ grid-template-columns: 1fr; }
}

/* ---- FAB（歯車ボタン） ---- */
#ctrlFab {
  position: fixed;
  right: 18px;
  bottom: 18px;
  z-index: 9999;
  width: 56px; height: 56px;
  border-radius: 999px;
  border: 1px solid #1a2236;
  background: #0e9bdd;
  color: #fff;
  font-weight: 800;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
}
#ctrlFab:focus{ outline: 2px solid #6fd3ff; outline-offset: 2px; }

/* オーバーレイ（半透明の背景） */
#ctrlOverlay{
  position: fixed; inset: 0;
  background: rgba(0,0,0,.35);
  backdrop-filter: blur(1px);
  z-index: 9997;
  opacity: 0; pointer-events: none;
  transition: opacity .2s ease;
}
#ctrlOverlay.is-open{
  opacity: 1; pointer-events: auto;
}

/* 既存のサンプル数ウォームアップ入力は控えめ表示 */
#inpWarm{ opacity: .35; }
#warmSyncNote{ font-size: 12px; color: #a5b4d4; }
</style>
<script id="spa-ui-patch-script">
(function(){
  // 1) 右カラム「コントロール」カードを見つけて id 付与（タイトルテキストで探索）
  function findControlsCard(){
    const cards = Array.from(document.querySelectorAll('.card'));
    for(const c of cards){
      const t = c.querySelector('.head .title');
      if(t && /コントロール/.test(t.textContent||'')){
        return c;
      }
    }
    return null;
  }
  const panel = findControlsCard();
  if(panel){ panel.id = 'controlsCard'; }

  // 2) FABとオーバーレイを動的追加
  const fab = document.createElement('button');
  fab.id = 'ctrlFab'; fab.type = 'button'; fab.title = 'コントロールを開く（Cキー）';
  fab.setAttribute('aria-controls', 'controlsCard');
  fab.setAttribute('aria-expanded', 'false');
  fab.textContent = '⚙️';

  const ovl = document.createElement('div');
  ovl.id = 'ctrlOverlay'; ovl.hidden = true;

  document.body.appendChild(fab);
  document.body.appendChild(ovl);

  function openPanel(){
    if(!panel) return;
    panel.classList.add('is-open');
    ovl.hidden = false;
    ovl.classList.add('is-open');
    fab.setAttribute('aria-expanded', 'true');
  }
  function closePanel(){
    if(!panel) return;
    panel.classList.remove('is-open');
    ovl.classList.remove('is-open');
    fab.setAttribute('aria-expanded', 'false');
    setTimeout(()=>{ if(!panel.classList.contains('is-open')) ovl.hidden = true; }, 220);
  }
  function togglePanel(){
    if(panel && panel.classList.contains('is-open')) closePanel(); else openPanel();
  }

  fab.addEventListener('click', togglePanel);
  ovl.addEventListener('click', closePanel);
  window.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) || '';
    const isTyping = /INPUT|TEXTAREA|SELECT/.test(tag);
    if(isTyping) return;
    if(e.key==='c' || e.key==='C'){ e.preventDefault(); togglePanel(); }
    if(e.key==='Escape'){ closePanel(); }
  });

  // 3) ウォームアップ「秒」入力を追加し、実効サンプル数に同期
  //    ・既存 #inpWarm（サンプル数） を見つけてすぐ隣に「秒」入力を追加
  //    ・実効レートは右カラムの #inpSpeed （描画速度/sps）を採用（エンジン側で使用）
  const inpWarm = document.getElementById('inpWarm');
  const inpSpeed = document.getElementById('inpSpeed'); // 実効サンプルレート（sps）
  if(inpWarm){
    // ラッパーを作成
    const wrap = document.createElement('div');
    wrap.style.marginTop = '6px';
    const lbl = document.createElement('label');
    lbl.textContent = 'SPA表示ウォームアップ（秒）';
    const warmSec = document.createElement('input');
    warmSec.type = 'number'; warmSec.id = 'inpWarmSec';
    warmSec.min = '0'; warmSec.max = '300'; warmSec.step = '0.5';
    warmSec.value = '5';
    warmSec.style.width = '100%';

    const note = document.createElement('div');
    note.id = 'warmSyncNote';
    note.textContent = '秒→サンプルへ自動換算（描画速度に追従）';

    // 既存 inpWarm の直後に挿入
    const parent = inpWarm.parentElement;
    parent && parent.appendChild(wrap);
    wrap.appendChild(lbl);
    wrap.appendChild(warmSec);
    wrap.appendChild(note);

    function toNumber(v, def=0){ const x=parseFloat(v); return Number.isFinite(x)? x : def; }
    function sps(){ return toNumber(inpSpeed && inpSpeed.value, 60); } // デフォ60sps

    function syncWarmSamplesFromSeconds(){
      const seconds = toNumber(warmSec.value, 0);
      const samples = Math.max(0, Math.round(seconds * sps()));
      // 既存サンプル入力へ反映（アプリ側はこれを参照する）
      inpWarm.value = String(samples);
      // 直接グローバル変数にも反映（既存コードが持つ warmupSamples を更新）
      try{
        if (typeof window !== 'undefined') {
          // 既存スコープにある変数へアクセスできない場合は、changeイベントを発火して既存ハンドラに任せる
          const ev = new Event('change', {bubbles:true});
          inpWarm.dispatchEvent(ev);
        }
      }catch(e){}
      note.textContent = `秒→サンプルへ自動換算（現在 ${sps()} sps / ${samples} samples）`;
    }

    // 初期同期
    syncWarmSamplesFromSeconds();
    // 秒入力 or sps変更のたびに同期
    warmSec.addEventListener('change', syncWarmSamplesFromSeconds);
    warmSec.addEventListener('input',  syncWarmSamplesFromSeconds);
    if(inpSpeed){
      inpSpeed.addEventListener('input',  syncWarmSamplesFromSeconds);
      inpSpeed.addEventListener('change', syncWarmSamplesFromSeconds);
    }
  }

  // 4) 初期はコントロール非表示（モニターを最大化して使える）
  //    起動時は閉じたまま。必要に応じて openPanel() を呼び出してください。
  //    ここではデフォルト閉じるだけにしておく。
})();
</script>
<!-- === /SPA UI Patch === -->
<script>
(function(){
  const kpiLevelBEl = document.getElementById('kpiLevelB');
  const kpiLevelBmaxEl = document.getElementById('kpiLevelBmax');
  if (!kpiLevelBEl || !kpiLevelBmaxEl) return;

  let peakBLevel = null;

  function parseLevel(text){
    if (!text) return null;
    const v = parseFloat(String(text).replace(/[^\d\.\-]/g,''));
    return (isNaN(v) || !isFinite(v)) ? null : v;
  }

  setInterval(function(){
    const v = parseLevel(kpiLevelBEl.textContent);
    if (typeof v === 'number' && isFinite(v)) {
      if (peakBLevel === null || v > peakBLevel) peakBLevel = v;
    }
    if (typeof peakBLevel === 'number' && isFinite(peakBLevel)) {
      const vv = Math.round(peakBLevel * 10) / 10;
      kpiLevelBmaxEl.textContent = vv.toFixed(1);
    } else {
      kpiLevelBmaxEl.textContent = '—';
    }
  }, 200);

  // reset() フック（A最大値と同様のリセットに追従）
  try {
    const origReset = window.reset;
    if (typeof origReset === 'function') {
      window.reset = function(){
        const r = origReset.apply(this, arguments);
        peakBLevel = null;
        if (kpiLevelBmaxEl) kpiLevelBmaxEl.textContent = '—';
        return r;
      };
    }
  } catch(e){ /* ignore */ }
})();
</script><script>
(function(){
  const warmUpMs = 1500; // ウォームアップ時間(ミリ秒) - 必要なら調整
  const kpiLevelAEl = document.getElementById('kpiLevelA');
  const kpiLevelAmaxEl = document.getElementById('kpiLevelAmax');
  const kpiLevelBmaxEl = document.getElementById('kpiLevelBmax');
  let startedAt = 0;
  let inWarmup = false;
  let prevWasWarmup = false;

  function now(){ return (window.performance && performance.now) ? performance.now() : Date.now(); }
  function beginWarmup(){
    startedAt = now();
    inWarmup = true;
  }
  function checkWarmup(){
    if (!inWarmup) return false;
    if (now() - startedAt >= warmUpMs) {
      inWarmup = false;
    }
    return inWarmup;
  }

  // 可能なら startScan と reset をフック
  try {
    if (typeof window.startScan === 'function') {
      const _origStart = window.startScan;
      window.startScan = function(){
        beginWarmup();
        return _origStart.apply(this, arguments);
      };
    } else {
      // フォールバック：初めてAに数値が入り始めた時点でウォームアップ開始
      const obs = new MutationObserver(function(){
        if (!inWarmup && kpiLevelAEl && /\d/.test(kpiLevelAEl.textContent||'')) {
          beginWarmup();
          obs.disconnect();
        }
      });
      if (kpiLevelAEl) obs.observe(kpiLevelAEl, {childList:true, characterData:true, subtree:true});
    }
  } catch(e){}

  try {
    if (typeof window.reset === 'function') {
      const _origReset = window.reset;
      window.reset = function(){
        const r = _origReset.apply(this, arguments);
        // 次回開始のためにウォームアップをいったん解除
        inWarmup = false;
        prevWasWarmup = false;
        if (kpiLevelAEl) kpiLevelAEl.textContent = '—';
        if (kpiLevelAmaxEl) kpiLevelAmaxEl.textContent = '—';
        if (kpiLevelBmaxEl) kpiLevelBmaxEl.textContent = '—';
        return r;
      };
    }
  } catch(e){}

  // 表示ゲート：ウォームアップ中はAの表示とA/B最大の更新を抑制
  // （DOMを書き換えることで最大値監視スクリプトが進まないようにする）
  setInterval(function(){
    const inW = checkWarmup();
    if (inW) {
      if (kpiLevelAEl && kpiLevelAEl.textContent !== '—') {
        kpiLevelAEl.textContent = '—';
      }
      if (kpiLevelAmaxEl && kpiLevelAmaxEl.textContent !== '—') {
        kpiLevelAmaxEl.textContent = '—';
      }
      if (kpiLevelBmaxEl && kpiLevelBmaxEl.textContent !== '—') {
        kpiLevelBmaxEl.textContent = '—';
      }
    } else {
      // ウォームアップから通常運転に切り替わった直後の一度だけ「—」を解除するだけでOK。
      if (prevWasWarmup) {
        // 解除時は何もしない（通常ロジックが上書き表示する）
      }
    }
    prevWasWarmup = inW;
  }, 100);
})();
</script>
<script>
// ===== ダウンロード名ハードガード =====
// どのコードパスでも <a href="blob:..."> のクリック直前に
// download 名を「場所_観測者_YYYYMMDD_HHMMSS.csv」に上書きする
(function(){
  var orig = HTMLAnchorElement.prototype.click;
  if (!orig || HTMLAnchorElement.prototype.__autonameGuard) return;
  HTMLAnchorElement.prototype.__autonameGuard = true;
  HTMLAnchorElement.prototype.click = function(){
    try{
      if (this && typeof this.href === 'string' && /^blob:/.test(this.href)) {
        var want = (window.makeCsvFilename ? window.makeCsvFilename() : 'spa_events.csv');
        if (!this.download || /spa_events_(with_gps|jst)\.csv$/i.test(this.download)) {
          this.setAttribute('download', want);
          this.download = want;
        }
      }
    }catch(e){ /* ignore */ }
    return orig.call(this);
  };
})();
</script>


<script>
// ===== スーパーガード版 =====
// 「イベントCSV」ボタン押下時に必ず次のCSV名を予約し、
// blob: リンクのクリック直前に .csv であれば必ずその名前に上書きする。
(function(){
  function ensureForceNameHook(){
    var btn = document.getElementById('btnExportCSV');
    if(!btn || btn.__forceNameHooked) return;
    btn.__forceNameHooked = true;
    btn.addEventListener('click', function(){
      try{
        if (window.makeCsvFilename) {
          window.__forceCsvName = window.makeCsvFilename();
        } else {
          window.__forceCsvName = 'spa_events.csv';
        }
      }catch(e){ window.__forceCsvName = 'spa_events.csv'; }
    }, {capture:true});
  }

  var origClick = HTMLAnchorElement.prototype.click;
  if (!HTMLAnchorElement.prototype.__superGuard && origClick){
    HTMLAnchorElement.prototype.__superGuard = true;
    HTMLAnchorElement.prototype.click = function(){
      try{
        var isBlob = this && typeof this.href === 'string' && /^blob:/i.test(this.href);
        var isCsv  = (this && typeof this.download === 'string' && /\.csv$/i.test(this.download))
                     || /\.csv(\?|#|$)/i.test(String(this.href||''));
        if (isBlob && isCsv){
          var want = window.__forceCsvName || (window.makeCsvFilename ? window.makeCsvFilename() : 'spa_events.csv');
          // どんな名前でも強制上書き（"spa_場所_..."等も含む）
          this.setAttribute('download', want);
          this.download = want;
        }
      }catch(e){ /* ignore */ }
      return origClick.call(this);
    };
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureForceNameHook);
  } else {
    ensureForceNameHook();
  }
})();
</script>

</body>
</html>
