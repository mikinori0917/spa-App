<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>SPAプロジェクト：リアルタイム異常検知アプリ（高速版・5秒平均SPAレベル）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220; --panel:#121a2a; --ink:#e6eefc; --muted:#a5b4d4; --accent:#6fd3ff; --accent2:#ffb86b; --danger:#ff6b6b; --ok:#20c997; --grid:#1c2740; --grid2:#223050;
    }
    *{box-sizing:border-box;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic UI","Yu Gothic","Meiryo",sans-serif}
    body{margin:0;background:var(--bg);color:var(--ink)}
    .wrap{display:grid;grid-template-columns:1fr 360px;gap:14px;min-height:100vh;padding:14px}
    .card{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.25);overflow:hidden;border:1px solid #1a2236}
    .head{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid #1a2236;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0))}
    .title{font-weight:700;letter-spacing:.2px}
    .canvas-wrap{position:relative;height:420px}
    canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,var(--grid) 0%, var(--grid2) 100%)}
    .legend{position:absolute;bottom:8px;left:10px;font-size:12px;color:var(--muted);background:rgba(0,0,0,.3);padding:4px 8px;border-radius:8px;border:1px solid #1a2236}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:6px}
    .pad{padding:12px 14px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    label{font-size:12px;color:var(--muted)}
    input[type="number"],input[type="text"],select{width:100%;background:#0e1626;color:var(--ink);border:1px solid #1a2236;border-radius:10px;padding:8px 10px;outline:none}
    input[type="range"]{width:100%}
    .btn{background:#0e9bdd;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.secondary{background:#2b3756}
    .btn.danger{background:#e84e4e}
    .kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
    .kpi .item{background:#0e1626;border:1px solid #1a2236;border-radius:12px;padding:10px}
    .kpi .val{font-size:20px;font-weight:800}
    .badge{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #1a2236;color:var(--muted)}
    .ok{color:var(--ok)} .warn{color:var(--accent2)} .ng{color:var(--danger)}
    .note{font-size:12px;color:var(--muted)}
    .audio-pill{font-size:12px;padding:4px 10px;border-radius:999px;border:1px solid #1a2236;background:#0e1626;color:var(--muted)}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
  </style>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

</head>
<body>
  <!-- ▼ Sampling Rate Control -->
  <div class="control-row" style="margin:8px 0; padding:8px; border:1px dashed #334; border-radius:8px;">
    <label for="samplingRate" style="display:block; font-weight:600;">サンプリング速度（回/秒）</label>
    <input type="range" id="samplingRate" min="5" max="120" value="10" step="5" style="width:100%;">
    <div style="display:flex; justify-content:space-between; font-size:12px; color:#9ab;">
      <span>5 Hz</span><span>120 Hz</span>
    </div>
    <div style="margin-top:4px; font-size:13px;">
      現在: <b><span id="samplingRateLabel">10</span> Hz</b>（<span id="samplingIntervalLabel">100</span> ms 間隔）
    </div>
  </div>
  <!-- ▲ Sampling Rate Control -->

  <!-- ▼ 超え率モード -->
  <div class="control-row" style="margin:8px 0; padding:8px; border:1px dashed #334; border-radius:8px;">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <label style="font-weight:600;">超え率モード</label>
      <label><input type="radio" name="freqMode" value="cumulative"> 累積</label>
      <label><input type="radio" name="freqMode" value="window" checked> 区間（直近 <input id="freqWindowSec" type="number" value="1" min="1" max="30" style="width:4em;"> 秒）</label>
      <button id="freqResetBtn" type="button" style="margin-left:auto; padding:4px 10px;">区間リセット</button>
    </div>
    <div style="margin-top:6px; font-size:13px;">
      現在の超え率: <b><span id="freqNowLabel">--</span></b>（<span id="freqModeLabel">区間</span>）
    </div>
  </div>
  <!-- ▲ 超え率モード -->


  <div class="wrap">
    <!-- Left: Strip Monitor -->
    <div class="card" id="monitorCard">
      <div class="head">
        <div class="row">
          <div class="title">ストリップモニタ（高速・5秒平均レベル）</div>
          <div class="audio-pill" id="audioStatus">音声: 無効（ページをクリック）</div>
        </div>
        <div class="row">
          <button class="btn" id="btnStart">スキャン実行</button>
          <button class="btn secondary" id="btnStop">停止</button>
          <button class="btn danger" id="btnReset">リセット</button>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="scope"></canvas>
        <div class="legend">閾値超過: 880Hz / 2σ超過: 1320Hz</div>
      </div>
      <div class="pad">
        <div class="kpi">
          <div class="item">
            <div class="badge">超え率（頻度）</div>
            <div class="val" id="kpiRate">0.0%</div>
          </div>
          <div class="item">
            <div class="badge">p値（区間平均）</div>
            <div class="val" id="kpiP">—</div>
          </div>
          <div class="item">
            <div class="badge">SPA値（区間平均）</div>
            <div class="val" id="kpiSPA">—</div>
          </div>
          <div class="item">
            <div class="badge">SPAレベル（区間平均×2.44）</div>
            <div class="val" id="kpiLevel">—</div>
          </div>
        
          <div class="item">
            <div class="badge">SPAレベル（期間平均A）</div>
            <div class="val" id="kpiLevelA">—</div>
            <div class="note">
              集計期間: <input type="number" id="inpAvgSecA" value="1" min="0.2" step="0.1" style="width:70px;"> 秒
              <span style="margin-left:10px;color:#8aa0b5">※ 第2位四捨五入→第1位表示</span>
            </div>
          </div>
          <div class="item">
            <div class="badge">SPAレベル（期間平均B）</div>
            <div class="val" id="kpiLevelB">—</div>
            <div class="note">
              集計期間: <input type="number" id="inpAvgSecB" value="5" min="0.5" step="0.5" style="width:70px;"> 秒
              <span style="margin-left:10px;color:#8aa0b5">※ 第2位四捨五入→第1位表示</span>
            </div>
          </div>
          <div class="item">
            <div class="badge">SPAレベル（期間平均C）</div>
            <div class="val" id="kpiLevelC">—</div>
            <div class="note">
              集計期間: <input type="number" id="inpAvgSecC" value="0" min="0" step="0.5" style="width:70px;"> 秒
              <span style="margin-left:10px;color:#8aa0b5">0 = 全時間（開始からの累積平均）</span>
            </div>
          </div>

</div>
        <div class="note" id="intervalNote">集計間隔: 5.0 秒</div>
      <div class="pad" id="gpsPanel" style="margin-top:12px; border-top:1px solid #1a2236; padding-top:12px;">
        <div class="title" style="font-size:14px; margin-bottom:6px;">位置情報（GPS）</div>
        <div class="row" style="gap:8px; flex-wrap:wrap;">
          <button class="btn" id="btnGeoStart">位置取得開始</button>
          <button class="btn secondary" id="btnGeoStop">停止</button>
          <button class="btn" id="btnGeoCopy">座標コピー</button>
          <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkAttachLoc" checked> 記録に座標を含める</label>
          <button class="btn secondary" id="btnExportCSV">イベントCSV</button>
        </div>
        <div class="grid" style="margin-top:8px">
          <div class="col"><label>緯度</label><input type="text" id="geoLat" readonly value="—"/></div>
          <div class="col"><label>経度</label><input type="text" id="geoLon" readonly value="—"/></div>
          <div class="col"><label>精度（m）</label><input type="text" id="geoAcc" readonly value="—"/></div>
          <div class="col"><label>速度（m/s）</label><input type="text" id="geoSpd" readonly value="—"/></div>
          <div class="col"><label>方位（deg）</label><input type="text" id="geoHead" readonly value="—"/></div>
          <div class="col"><label>時刻</label><input type="text" id="geoTime" readonly value="—"/></div>
        </div>
        <div class="note" id="geoStatus" style="margin-top:6px">GPS: 未開始（許可が必要）</div>
      </div>
      <div class="pad" id="placePanel" style="margin-top:12px; border-top:1px solid #1a2236; padding-top:12px;">
        <div class="title" style="font-size:14px; margin-bottom:6px;">場所メモ（手打ち）</div>
        <div class="grid" style="gap:10px">
          <div class="col">
            <label>場所名</label>
            <input type="text" id="placeName" placeholder="例：第3ライン 2番機 入口付近" />
          </div>
          <div class="col">
            <label>備考（任意）</label>
            <input type="text" id="placeMemo" placeholder="例：午前のみ稼働、高温注意 など" />
          </div>
        </div>
        <div class="row" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
          <button class="btn" id="btnSetPlace">現在の場所にセット</button>
          <button class="btn secondary" id="btnClearPlace">クリア</button>
          <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="chkIncludePlace" checked> 記録に場所名を含める</label>
          <button class="btn" id="btnManualLog">今を記録</button>
        </div>
        <div class="row" id="autoLogRow" style="gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
          <label style="display:flex;align-items:center;gap:6px">
            <input type="checkbox" id="chkAutoSpaLog" checked> SPAレベル自動記録（≧）
          </label>
          <input type="number" id="inpSpaLevelThresh" value="2.1" step="0.1" min="0" max="99"
                 style="width:90px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;border-radius:8px;padding:6px 8px">
<select id="selSpaLevelTarget" style="padding:4px 6px;border-radius:8px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;"><option value="A">A</option><option value="B">B</option><option value="C" selected>C</option></select>
          <input type="text" id="logNote" placeholder="メモ（任意）"
                 style="flex:1;min-width:180px;background:#0e1626;color:#e6eefc;border:1px solid #1a2236;border-radius:8px;padding:6px 8px">
        </div>

      </div>

      </div>
    </div>
    <!-- Right: Controls -->
    <div class="card">
      <div class="head">
        <div class="title">コントロール</div>
        <span class="note">完全オフライン / 外部CDN不要</span>
      </div>
      <div class="pad">
        <div class="grid">
          <div class="col">
            <label>ウィンドウ幅 N（点）</label>
            <input type="number" id="inpN" min="100" max="5000" step="50" value="1200"/>
          </div>
          <div class="col">
            <label>描画速度（サンプル/秒）</label>
            <input type="range" id="inpSpeed" min="5" max="120" step="1" value="120"/>
            <div class="note" id="speedLabel">60 sps</div>
          </div>
          <div class="col">
            <label>T（ステップ標準偏差）</label>
            <input type="number" id="inpSigma" min="0.1" max="10" step="0.1" value="1.2"/>
          </div>
          <div class="col">
            <label>ドリフト抑制 α（0..1 小さいほど自由）</label>
            <input type="range" id="inpAlpha" min="0" max="0.1" step="0.002" value="0.100"/>
            <div class="note" id="alphaLabel">α = 0.100</div>
          </div>
          <div class="col">
            <label>閾値 |x| &gt;= </label>
            <input type="number" id="inpThresh" min="0.5" max="100" step="0.5" value="6"/>
          </div>
          <div class="col">
            <label>閾値モード</label>
            <select id="selThreshMode">
              <option value="abs" selected>絶対値（|x| ≥ 閾値）</option>
              <option value="z">Zスコア（|z| ≥ 閾値）</option>
            </select>
          </div>
          <div class="col">
            <label>縦軸モード</label>
            <select id="selYMode">
              <option value="fixed" selected>固定（±Ymax）</option>
              <option value="auto">AUTO</option>
            </select>
          </div>
          <div class="col">
            <label>Ymax（固定時）</label>
            <input type="number" id="inpYmax" min="2" max="200" step="1" value="25"/>
          </div>
          <div class="col">
            <label>2σ判定の窓幅（点）</label>
            <input type="number" id="inpZwin" min="30" max="2000" step="10" value="400"/>
          </div>
          <div class="col">
            <label>ビープ音</label>
            <select id="selAudio">
              <option value="on" selected>オン</option>
              <option value="off">オフ</option>
            </select>
          </div>
          <div class="col">
            <label>SPA方式</label>
            <select id="selSpaMode">
              <option value="freq">頻度SPA（従来）</option>
              <option value="inst" selected>瞬間Z p（新方式）</option>
              <option value="batch">バッチp（窓で1回以上）</option>
            </select>
          </div>
          <div class="col">
            <label>SPA表示ウォームアップ（サンプル）</label>
            <input type="number" id="inpWarm" min="0" max="5000" step="50" value="500"/>
          </div>
          <div class="col">
            <label>レベル集計間隔（秒）</label>
            <input type="number" id="inpIntervalSec" min="1" max="30" step="0.5" value="1"/>
          </div>
          <div class="col">
    <label>音量スケール</label>
    <input type="range" id="rngVolScale" min="0.2" max="3.0" step="0.05" value="1.0"/>
    <div><small id="lblVolScale">1.00×</small></div>
  </div>
  <div class="col">
    <label>ピッチ刻み（Hz/レベル）</label>
    <input type="range" id="rngPitchStep" min="40" max="400" step="5" value="160"/>
    <div><small id="lblPitchStep">160 Hz/level</small></div>
  </div>
  <div class="col">
    <label>最大音量キャップ</label>
    <input type="range" id="rngVolMax" min="0.1" max="1.0" step="0.01" value="1.0"/>
    <div><small id="lblVolMax">1.00</small></div>
  </div>
  <div class="col">
    <label>プリセット</label>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button id="btnPresetQuiet" type="button">静音</button>
      <button id="btnPresetNormal" type="button">標準</button>
      <button id="btnPresetStrong" type="button" style="background:#e03131;color:#fff;">強演出</button>
    </div>
    <label style="margin-top:6px;display:block;"><input type="checkbox" id="chkStrongFX"> 強演出エフェクトを有効化（フラッシュ/バイブ）</label>
  </div>
  <div class="col">
    <label>波形</label>
    <select id="selWave">
      <option value="sine" selected>サイン</option>
      <option value="triangle">トライアングル</option>
      <option value="sawtooth">のこぎり波</option>
      <option value="square">矩形</option>
    </select>
  </div>
  <div class="col">
    <label>ディストーション</label>
    <input type="range" id="rngDist" min="0" max="40" step="1" value="0"/>
    <div><small id="lblDist">0</small></div>
  </div>
  <div class="col">
    <label>フラッシュ・スタイル</label>
    <select id="selFlash">
      <option value="red" selected>赤（ラジアル）</option>
      <option value="white">白（ストロボ）</option>
      <option value="blue">青（ラジアル）</option>
    </select>
    <label style="margin-top:6px;display:block;"><input type="checkbox" id="chkAutoStrong" checked> 起動時に強演出を自動ON</label>
  </div>
  <div class="col">
    <label>テスト</label>
    <button id="btnTestFlash" type="button">フラッシュテスト</button>
  </div>
</div>
        <hr style="border-color:#1a2236;margin:14px 0">
        <div class="col">
          <label>メモ</label>
          <div class="note">SPAレベルは「直近の集計間隔」での平均SPAを用い、表示もその間隔ごとに更新します（ラッチ表示）。</div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  // ---------- Utilities ----------
  const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
  const randn=(()=>{ let spare=null; return ()=>{ if(spare!==null){ const v=spare; spare=null; return v; } let u=0,v=0,s=0; do{ u=Math.random()*2-1; v=Math.random()*2-1; s=u*u+v*v; }while(!s||s>=1); const mul=Math.sqrt(-2*Math.log(s)/s); spare=v*mul; return u*mul; };})();

  // erf 近似（Abramowitz & Stegun 7.1.26）
  function erf(x){
    const sign = Math.sign(x) || 1; x = Math.abs(x);
    const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
    const t=1/(1+p*x); const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
    return sign*y;
  }
  const Phi = z => 0.5*(1+erf(z/Math.SQRT2)); // 標準正規CDF

  // ---------- DOM ----------
  const canvas=document.getElementById('scope');
  const ctx=canvas.getContext('2d', { alpha:false, desynchronized:true });
  const intervalNote = document.getElementById('intervalNote');

  function resize(){ const dpr=1; const rect=canvas.getBoundingClientRect(); canvas.width=Math.floor(rect.width*dpr); canvas.height=Math.floor(rect.height*dpr); rebuildGrid(); }
  const gridCanvas = document.createElement('canvas'); const gg = gridCanvas.getContext('2d', {alpha:false});

  function rebuildGrid(){
    gridCanvas.width = canvas.width; gridCanvas.height = canvas.height;
    const w=gridCanvas.width, h=gridCanvas.height;
    gg.clearRect(0,0,w,h);
    gg.strokeStyle='rgba(255,255,255,0.05)'; gg.lineWidth=1;
    const gy=10;
    for(let i=0;i<=gy;i++){ const y=Math.round(i*h/gy)+.5; gg.beginPath(); gg.moveTo(0,y); gg.lineTo(w,y); gg.stroke(); }
    const gx=24;
    for(let x=0;x<=w;x+=gx){ gg.beginPath(); gg.moveTo(x+0.5,0); gg.lineTo(x+0.5,h); gg.stroke(); }
  }
  resize(); addEventListener('resize', resize);

  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');
  const audioStatus = document.getElementById('audioStatus');

  const inpN = document.getElementById('inpN');
  const inpSpeed = document.getElementById('inpSpeed');
  const speedLabel = document.getElementById('speedLabel');
  const inpSigma = document.getElementById('inpSigma');
  const inpAlpha = document.getElementById('inpAlpha');
  const alphaLabel = document.getElementById('alphaLabel');
  const inpThresh = document.getElementById('inpThresh');
  const selThreshMode=document.getElementById('selThreshMode');
  const selYMode = document.getElementById('selYMode');
  const inpYmax  = document.getElementById('inpYmax');
  const inpZwin  = document.getElementById('inpZwin');
  const selAudio = document.getElementById('selAudio');
  const selSpaMode = document.getElementById('selSpaMode');
  const inpWarm    = document.getElementById('inpWarm');
  const inpIntervalSec = document.getElementById('inpIntervalSec');

  const kpiRate=document.getElementById('kpiRate');
  const kpiP=document.getElementById('kpiP');
  const kpiSPA=document.getElementById('kpiSPA');
  const kpiLevel=document.getElementById('kpiLevel');
  const kpiLevelA=document.getElementById('kpiLevelA');
  const kpiLevelB=document.getElementById('kpiLevelB');
  const inpAvgSecA=document.getElementById('inpAvgSecA');
  const inpAvgSecB=document.getElementById('inpAvgSecB');
  const kpiLevelC=document.getElementById('kpiLevelC');
  const inpAvgSecC=document.getElementById('inpAvgSecC');


  // ---------- Audio ----------
  let AC=null, masterGain=null, audioReady=false;
  function ensureAudio(){
    try{
      if(!AC){ AC=new (window.AudioContext||window.webkitAudioContext)(); }
      if(AC.state==="suspended"){ AC.resume(); }
      if(!masterGain){ masterGain=AC.createGain(); masterGain.gain.value=0.12; masterGain.connect(AC.destination); }
      audioReady=true; audioStatus.textContent="音声: 有効"; audioStatus.style.color="#20c997";
    }catch(e){ console.warn(e); }
  }
  window.addEventListener('pointerdown', ()=>{ ensureAudio(); }, {once:false});

  
  function dynBeep(kind="th"){ // kind: 'th' (閾値) | 'z' (2σ)
    if(!audioReady || selAudio.value==="off") return;
    const now = AC.currentTime;
    const mast = masterGain;
    function tone(f0, dur=0.12, sweepTo=null, gain=0.12, type="sine"){
      const o=AC.createOscillator(); const g=AC.createGain();
      o.type=type;
      o.frequency.setValueAtTime(Math.max(40, f0), now);
      if(sweepTo && isFinite(sweepTo)){
        o.frequency.exponentialRampToValueAtTime(Math.max(40, sweepTo), now + dur*0.9);
      }
      // ADSR-ish envelope
      const a=0.02, d=0.08, sLvl=gain*0.5, r=0.06;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(gain, now + a);
      g.gain.exponentialRampToValueAtTime(sLvl, now + a + d);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.connect(g).connect(mast);
      o.start(now);
      o.stop(now + dur + r);
    }
    function chord(base, dur){
      tone(base, dur, base*1.8, 0.14, "sine");     // 基音：上昇スイープ
      tone(base*1.5, dur, base*2.6, 0.08, "square"); // 5度：倍音強め
    }
    if(kind === "z"){
      // 2σ超え：二連チャイム（上昇スイープ×2）
      chord(900, 0.18);
      setTimeout(()=>chord(900, 0.18), 100);
    }else{
      // 閾値超え：軽めのワンショット（上昇スイープ）
      tone(650, 0.12, 1000, 0.10, "sine");
      tone(975, 0.10, 1500, 0.05, "triangle"); // 5度の薄いハーモニー
    }
  }


  // ---------- State ----------
  let N = parseInt(inpN.value,10);
  let buffer = new Float32Array(N).fill(0);
  let head = N-1; let x = 0; let running=false;
  let sampleIntervalMs = 1000/parseFloat(inpSpeed.value);
  let sigma = parseFloat(inpSigma.value);
  let alpha = parseFloat(inpAlpha.value);
  let threshold = parseFloat(inpThresh.value);
  let zWindow = parseInt(inpZwin.value,10);
  let warmupSamples = parseInt(inpWarm.value,10);
  let intervalSec = parseFloat(inpIntervalSec.value);

  // 2σ用：O(1)ローリング統計（合計・二乗和）
  let zBuf = new Float32Array(zWindow);
  let zHead = -1, zCount = 0, zSum = 0, zSumSq = 0;
  function rebuildZ(windowSize){
    zBuf = new Float32Array(windowSize); zHead=-1; zCount=0; zSum=0; zSumSq=0;
  }

  function pushZ(v){
    zHead = (zHead + 1) % zWindow;
    if (zCount < zWindow){
      zBuf[zHead] = v; zSum += v; zSumSq += v*v; zCount++;
    } else {
      const old = zBuf[zHead];
      zBuf[zHead] = v;
      zSum += v - old;
      zSumSq += v*v - old*old;
    }
  }
  function rollingStatsFast(){
    const m = zCount || 1;
    const mean = zSum / m;
    const var_ = (zSumSq - (zSum*zSum)/m) / Math.max(1, m-1);
    return { mean, std: Math.sqrt(var_) || 1, count: zCount };
  }

  // stats（頻度SPA用）
  let totalSamples=0; let exceedCount=0;
  let p_freq_raw = 0;

  // 区間平均SPAのためのバッファ（時刻付き）
  const spaTimes = []; const spaVals = [];
  // A/B ラッチ更新用の状態
  let lastALatched = null, lastBLatched = null;
  let nextLatchA = (typeof performance!=='undefined' ? performance.now() : Date.now());
  let nextLatchB = (typeof performance!=='undefined' ? performance.now() : Date.now());
  // A/B 専用の期間窓（時刻付き）
  const winAT = []; const winAV = [];
  const winBT = []; const winBV = [];
  // C ラッチ＆期間窓／累積
  let lastCLatched = null;
  let nextLatchC = (typeof performance!=='undefined' ? performance.now() : Date.now());
  const winCT = []; const winCV = [];
  let cumSpaSum = 0, cumSpaCount = 0;
  let lastDisplay = {p:null, spa:null, level:null};
  let nextLatchTime = performance.now() + intervalSec*1000;

  function spaLevelText(spa){
    if (isNaN(spa) || !isFinite(spa)) return '—';
    if (spa < 1)   return 'LOW';
    if (spa < 2)   return 'MID';
    if (spa < 3)   return 'HIGH';
    if (spa < 4)   return 'V.HIGH';
    return 'EXTREME';
  }

  function reset(){
    buffer = new Float32Array(N).fill(0); head=N-1; x=0;
    totalSamples=0; exceedCount=0;
    zBuf.fill(0); zHead=-1; zCount=0; zSum=0; zSumSq=0;
    spaTimes.length=0; spaVals.length=0;
    lastDisplay={p:null,spa:null,level:null};
    nextLatchTime = performance.now() + intervalSec*1000;
  }

  function reallocate(newN){
    const old=buffer; const copyLen=Math.min(old.length,newN); const next=new Float32Array(newN).fill(0);
    for(let i=0;i<copyLen;i++){ next[newN-1-i]=old[old.length-1-i]; }
    buffer=next; N=newN; head=N-1;
  }
  function add(v){ head=(head+1)%N; buffer[head]=v; }
  function getAt(i){ const idx=(head-(N-1-i)); const j=(idx>=0)?(idx%N):((idx%N)+N); return buffer[j]; }

  // ---------- Simulation (with interval latch) ----------
  let accum = 0, lastSim = performance.now(), lastDraw = performance.now();
  const MAX_STEPS_PER_FRAME = 256;
  const DRAW_INTERVAL_MS = 1000/60;

  function simulateStep(now){
    const drifted = (1-alpha)*x + sigma*randn(); x = drifted;
    add(x); pushZ(x);

    const stats = rollingStatsFast();
    const z = (x - stats.mean) / (stats.std || 1);

    let exceeded=false, zExceeded=false;
    if(selThreshMode.value==='abs'){ exceeded = Math.abs(x) >= threshold; } else { exceeded = Math.abs(z) >= threshold; }
    zExceeded = Math.abs(z) >= 2.0;

    totalSamples++; if(exceeded) exceedCount++;
    if(zExceeded){ dynBeep('z'); try{ logEvent('z', {spa: spaVals.length? spaVals[spaVals.length-1]: null, p: null}); }catch(e){} } else if(exceeded){ dynBeep('th'); try{ logEvent('th', {spa: spaVals.length? spaVals[spaVals.length-1]: null, p: null}); }catch(e){} }

    // 周波数ベース指標は継続更新
    p_freq_raw = exceedCount / Math.max(1,totalSamples);

    // p/SPA（瞬間）→ バッファに保存（ウォームアップ後）
    if(totalSamples >= warmupSamples){
      const mode = selSpaMode.value;
      let p_show = null;
      if(mode === 'freq'){
        const p_freq = (exceedCount + 1) / (totalSamples + 2);
        p_show = p_freq;
      }else if(mode === 'inst'){
        const p_inst = 2*(1 - Phi(Math.abs(z)));
        p_show = Math.max(Number.EPSILON, Math.min(1, p_inst));
      }else if(mode === 'batch'){
        const p_inst = 2*(1 - Phi(Math.abs(z)));
        const m = Math.max(1, stats.count);
        const p_batch = 1 - Math.pow(1 - p_inst, m);
        p_show = Math.max(Number.EPSILON, Math.min(1, p_batch));
      }
      if(p_show!=null){
        const spa = -Math.log10(p_show);
        spaTimes.push(now); spaVals.push(spa);
        // A/B windows
        const secA = Math.max(0.1, parseFloat(inpAvgSecA?.value)||1);
        const secB = Math.max(0.1, parseFloat(inpAvgSecB?.value)||5);
        winAT.push(now); winAV.push(spa);
        winBT.push(now); winBV.push(spa);
        const cutA = now - secA*1000; const cutB = now - secB*1000;
        while(winAT.length && winAT[0] < cutA){ winAT.shift(); winAV.shift(); }
        while(winBT.length && winBT[0] < cutB){ winBT.shift(); winBV.shift(); }
        // --- ラッチ更新（A/Bそれぞれの周期で更新） ---
        if(now >= nextLatchA){
          if(winAV.length){ let s=0; for(let i=0;i<winAV.length;i++){ s+=winAV[i]; }
            const avgA = s/winAV.length; lastALatched = avgA*2.44; } else { lastALatched = null; }
          nextLatchA = now + secA*1000;
        }
        if(now >= nextLatchB){
          if(winBV.length){ let s=0; for(let i=0;i<winBV.length;i++){ s+=winBV[i]; }
            const avgB = s/winBV.length; lastBLatched = avgB*2.44; } else { lastBLatched = null; }
          nextLatchB = now + secB*1000;
        }
      
        // C 期間（0 => 全時間）
        const secC = Math.max(0, parseFloat(inpAvgSecC?.value)||0);
        if (secC > 0) {
          // windowed C
          winCT.push(now); winCV.push(spa);
          const cutC = now - secC*1000;
          while(winCT.length && winCT[0] < cutC){ winCT.shift(); winCV.shift(); }
        } else {
          // cumulative C
          cumSpaSum += spa; cumSpaCount += 1;
        }
        // --- ラッチ更新（Cの周期で更新：secC秒 / 0のとき1秒） ---
        if (now >= nextLatchC){
          let avgC = null;
          if (secC > 0) {
            if (winCV.length){ let s=0; for(let i=0;i<winCV.length;i++){ s+=winCV[i]; } avgC = s/winCV.length; }
          } else {
            if (cumSpaCount > 0){ avgC = cumSpaSum / cumSpaCount; }
          }
          lastCLatched = (avgC!=null) ? (avgC*2.44) : null;
          nextLatchC = now + (secC>0 ? secC*1000 : 1000);
        }
}
    }

    // 古いSPAを捨てる（直近intervalSecのみ保持）
    const cut = now - intervalSec*1000;
    while(spaTimes.length && spaTimes[0] < cut){ spaTimes.shift(); spaVals.shift(); }

    // ラッチ更新：一定間隔ごとに平均SPAで表示を更新
    if(now >= nextLatchTime){
      if(spaVals.length){
        const avgSpa = spaVals.reduce((a,b)=>a+b,0)/spaVals.length;
        const avgP = Math.pow(10, -avgSpa);
        const level = spaLevelText(avgSpa);
        lastDisplay = { p: avgP.toFixed(6), spa: avgSpa.toFixed(2), level: (avgSpa*2.44).toFixed(1) + " / " + level };
      }else{
        lastDisplay = { p: '—', spa: '—', level: '—' };
      }
      nextLatchTime = now + intervalSec*1000;
    }
  }

  function loop(now){
    const dt = now - lastSim; lastSim = now; accum += dt;
    const tick = sampleIntervalMs; let steps = 0;
    while(accum >= tick && steps < MAX_STEPS_PER_FRAME){ simulateStep(now); accum -= tick; steps++; }
    if(now - lastDraw >= DRAW_INTERVAL_MS){ draw(); lastDraw = now; }
    requestAnimationFrame(loop);
  }

  // ---------- Drawing ----------
  function draw(){
    const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h);
    ctx.drawImage(gridCanvas, 0, 0);

    // y scale
    let yMin,yMax;
    if(selYMode.value==='fixed'){ const ymax=Math.max(2, parseFloat(inpYmax.value)); yMin=-ymax; yMax=ymax; }
    else{
      let mn=Infinity,mx=-Infinity, step=Math.max(1, Math.floor(N/8));
      for(let i=0;i<N;i+=step){ const v=getAt(i); if(v<mn) mn=v; if(v>mx) mx=v; }
      const marg=0.2*Math.max(1,(mx-mn)||1); yMin=mn-marg; yMax=mx+marg; if(!isFinite(yMin)||!isFinite(yMax)||yMin===yMax){ yMin=-10; yMax=10; }
    }
    const yToPix = val => h - (val - yMin) * (h/(yMax - yMin));

    // zero
    ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); const y0=yToPix(0); ctx.moveTo(0,y0); ctx.lineTo(w,y0); ctx.stroke();

    // plot
    ctx.lineWidth = 2; ctx.strokeStyle = "#6fd3ff"; ctx.beginPath();
    for(let i=0;i<N;i++){ const val=getAt(i); const xx=i*w/(N-1); const yy=yToPix(val); if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy); } ctx.stroke();

    // 閾値ライン（abs時）
    if(selThreshMode.value==='abs'){
      const thr=Math.abs(threshold);
      ctx.strokeStyle="rgba(255,184,107,0.9)";
      ctx.beginPath(); ctx.moveTo(0,yToPix(thr)); ctx.lineTo(w,yToPix(thr)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,yToPix(-thr)); ctx.lineTo(w,yToPix(-thr)); ctx.stroke();
    }

    // 2σ線
    const stats = rollingStatsFast();
    const upper=stats.mean + 2*stats.std, lower=stats.mean - 2*stats.std;
    ctx.strokeStyle="rgba(255,107,107,0.9)";
    ctx.beginPath(); ctx.moveTo(0,yToPix(upper)); ctx.lineTo(w,yToPix(upper)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,yToPix(lower)); ctx.lineTo(w,yToPix(lower)); ctx.stroke();

    // KPI（ラッチ表示）
    kpiRate.textContent = (p_freq_raw*100).toFixed(1)+"%";
    kpiP.textContent = lastDisplay.p ?? '—';
    kpiSPA.textContent = lastDisplay.spa ?? '—';
    kpiLevel.textContent = lastDisplay.level ?? '—';
  
    // A/B latched SPA level display (updates every A秒 / B秒)
    function r1(x){ return (Math.round(x*10)/10).toFixed(1); }
    
    // C専用：小数点以下2桁表示（下三桁四捨五入）
    function r2(x){ return (Math.round(x*100)/100).toFixed(2); }
if(kpiLevelA){ kpiLevelA.textContent = (lastALatched!=null) ? r1(lastALatched) : '—'; }
    if(kpiLevelB){ kpiLevelB.textContent = (lastBLatched!=null) ? r1(lastBLatched) : '—'; }

    if(kpiLevelC){ kpiLevelC.textContent = (lastCLatched!=null) ? r2(lastCLatched) : '—'; }
}

  // ---------- Wire UI ----------
  btnStart.addEventListener('click', ()=>{ ensureAudio(); requestAnimationFrame(loop); });
  btnStop .addEventListener('click', ()=>{ /* ループは停止させず描画のみ止めるのではなく、完全停止 */ location.reload(); });
  btnReset.addEventListener('click', ()=>{ reset(); draw(); });

  inpN.addEventListener('change', ()=>{ const v=clamp(parseInt(inpN.value,10)||1200,100,5000); inpN.value=v; reallocate(v); draw(); });
  inpSpeed.addEventListener('input', ()=>{ sampleIntervalMs = 1000/parseFloat(inpSpeed.value); speedLabel.textContent = inpSpeed.value + " sps"; });
  inpSigma.addEventListener('change', ()=>{ sigma = parseFloat(inpSigma.value)||1; });
  inpAlpha.addEventListener('input', ()=>{ alpha=parseFloat(inpAlpha.value)||0; alphaLabel.textContent = "α = " + alpha.toFixed(3); });
  inpThresh.addEventListener('change', ()=>{ threshold = Math.abs(parseFloat(inpThresh.value)||6); });
  selThreshMode.addEventListener('change', draw);
  selYMode.addEventListener('change', draw);
  inpYmax.addEventListener('change', draw);
  inpZwin.addEventListener('change', ()=>{
    const v = clamp(parseInt(inpZwin.value,10)||400,30,2000);
    if(v !== zWindow){
      // 既存データから再構築
      const tmp = new Float32Array(v);
      let count = 0;
      for(let i=0;i<v && i<N;i++){ tmp[i] = getAt(N-1-i); count++; }
      zWindow = v; rebuildZ(zWindow);
      for(let i=count-1;i>=0;i--){ pushZ(tmp[i]); }
    }
  });
  selSpaMode.addEventListener('change', ()=>{});
  inpWarm.addEventListener('change', ()=>{ warmupSamples = clamp(parseInt(inpWarm.value,10)||0,0,5000); });
  inpIntervalSec.addEventListener('change', ()=>{
    intervalSec = Math.max(1, Math.min(30, parseFloat(inpIntervalSec.value)||5));
    inpIntervalSec.value = intervalSec;
    intervalNote.textContent = "集計間隔: " + intervalSec.toFixed(1) + " 秒";
  });

  // initial render
  draw();

  // ---------- GPS / Geolocation ----------
  const btnGeoStart = document.getElementById('btnGeoStart');
  const btnGeoStop  = document.getElementById('btnGeoStop');
  const btnGeoCopy  = document.getElementById('btnGeoCopy');
  const geoLat = document.getElementById('geoLat');
  const geoLon = document.getElementById('geoLon');
  const geoAcc = document.getElementById('geoAcc');
  const geoSpd = document.getElementById('geoSpd');
  const geoHead= document.getElementById('geoHead');
  const geoTime= document.getElementById('geoTime');
  const geoStatus = document.getElementById('geoStatus');
  const chkAttachLoc = document.getElementById('chkAttachLoc');
  const btnExportCSV = document.getElementById('btnExportCSV');

  let geoWatchId = null;
  let lastGeo = null; // {lat, lon, acc, spd, head, ts}

  function fmt(n, d=6){ return (typeof n==='number' && isFinite(n)) ? n.toFixed(d) : '—'; }
  function iso(t){ try{ return new Date(t).toISOString(); }catch(e){ return '—'; } }

  function startGeo(){
    if(!('geolocation' in navigator)){
      geoStatus.textContent = 'GPS: 非対応ブラウザ';
      return;
    }
    if(geoWatchId!==null){ geoStatus.textContent='GPS: 実行中'; return; }
    geoStatus.textContent='GPS: 起動中…（ブラウザの許可を確認）';
    geoWatchId = navigator.geolocation.watchPosition(
      pos => {
        const c = pos.coords;
        lastGeo = {
          lat: c.latitude, lon: c.longitude,
          acc: c.accuracy, spd: (c.speed!=null? c.speed : NaN),
          head: (c.heading!=null? c.heading : NaN),
          ts: pos.timestamp
        };
        geoLat.value = fmt(lastGeo.lat, 6);
        geoLon.value = fmt(lastGeo.lon, 6);
        geoAcc.value = fmt(lastGeo.acc, 1);
        geoSpd.value = isFinite(lastGeo.spd)? fmt(lastGeo.spd, 2) : '—';
        geoHead.value= isFinite(lastGeo.head)? fmt(lastGeo.head, 1) : '—';
        geoTime.value = formatJST(pos && pos.timestamp ? pos.timestamp : (Date.now())) ;
        geoStatus.textContent = 'GPS: 受信中（高精度）';
      },
      err => {
        geoStatus.textContent = 'GPSエラー: ' + (err && err.message ? err.message : String(err));
      },
      { enableHighAccuracy: true, maximumAge: 5000, timeout: 15000 }
    );
  }
  function stopGeo(){
    if(geoWatchId!=null){
      try{ navigator.geolocation.clearWatch(geoWatchId); }catch(e){}
      geoWatchId = null;
      geoStatus.textContent = 'GPS: 停止';
    }
  }
  function copyCoords(){
    const txt = (lastGeo? (lastGeo.lat + ',' + lastGeo.lon) : '—');
    navigator.clipboard && navigator.clipboard.writeText(txt).then(()=>{
      geoStatus.textContent = '座標をクリップボードにコピーしました';
    }).catch(()=>{
      geoStatus.textContent = 'コピーできませんでした';
    });
  }

  btnGeoStart.addEventListener('click', startGeo);
  btnGeoStop .addEventListener('click', stopGeo);
  btnGeoCopy .addEventListener('click', copyCoords);

  // ---------- Event logging with GPS ----------
  const eventLog = []; // {timeISO, epoch, type:'th'|'z', spa?, p?, lat?, lon?, acc?}
  function logEvent(kind, meta={}){
    if(!chkAttachLoc.checked) return;
    const g = lastGeo || {};
    const rec = {
      timeISO: new Date().toISOString(),
      epoch: Date.now(),
      type: kind,
      spa: (meta && typeof meta.spa==='number') ? meta.spa : null,
      p: (meta && typeof meta.p==='number') ? meta.p : null,
      lat: (typeof g.lat==='number')? g.lat : null,
      lon: (typeof g.lon==='number')? g.lon : null,
      acc: (typeof g.acc==='number')? g.acc : null,
      spd: (typeof g.spd==='number')? g.spd : null,
      head:(typeof g.head==='number')? g.head : null
    };
    eventLog.push(rec);
  }
  function exportCSV(){
    if(!eventLog.length){
      geoStatus.textContent = 'エクスポート対象のイベントがありません';
      return;
    }
    const header = ['timeISO','epoch','type','spa','p','lat','lon','acc','spd','head','place','note'];
    const rows = [header.join(',')].concat(
      eventLog.map(r => header.map(k => (r[k]==null? '' : r[k])).join(','))
    );
    const blob = new Blob([rows.join('\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_with_gps.csv';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    geoStatus.textContent = 'CSVを書き出しました（ダウンロードを確認）';
  }
  btnExportCSV.addEventListener('click', exportCSV);


  // ---- Place (manual) wiring ----
  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const btnSetPlace = document.getElementById('btnSetPlace');
  const btnClearPlace = document.getElementById('btnClearPlace');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  const btnManualLog = document.getElementById('btnManualLog');
  let currentPlace = { name: '', memo: '' };

  function setCurrentPlace(){
    currentPlace = { name: (placeNameEl.value||'').trim(), memo: (placeMemoEl.value||'').trim() };
    if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent = currentPlace.name ? ('場所をセット: ' + currentPlace.name) : '場所をクリアしました'; }
  }
  function clearPlace(){
    placeNameEl.value=''; placeMemoEl.value=''; currentPlace = {name:'', memo:''};
    if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent='場所をクリアしました'; }
  }
  btnSetPlace && btnSetPlace.addEventListener('click', setCurrentPlace);
  btnClearPlace && btnClearPlace.addEventListener('click', clearPlace);

  // keep original reference
  const __origLogEvent = (typeof logEvent==='function') ? logEvent : null;
  function logEvent(kind, meta={}){
    if(!__origLogEvent) return;
    const include = (chkIncludePlace && chkIncludePlace.checked);
    const placeStr = include ? (currentPlace.name || placeNameEl.value || '') : '';
    const noteStr  = (meta && typeof meta.note==='string') ? meta.note : (placeMemoEl ? placeMemoEl.value : '');
    const meta2 = Object.assign({}, meta, { place: placeStr, note: noteStr });
    // Forward to original
    __origLogEvent(kind, meta2);
  }

  // manual log button
  btnManualLog && btnManualLog.addEventListener('click', ()=>{
    try{
      const spaTxt = (document.getElementById('kpiSPA')||{}).textContent || '';
      const pTxt = (document.getElementById('kpiP')||{}).textContent || '';
      const spa = parseFloat(spaTxt); const p = parseFloat(pTxt);
      logEvent('manual', {spa: isFinite(spa)? spa : null, p: isFinite(p)? p : null});
      if(typeof geoStatus!=='undefined' && geoStatus){ geoStatus.textContent='現在の状態を記録しました'; }
    }catch(e){}
  });


  // ---- Override GPS timestamp display to JST ----
  function formatJST(ts){
    try{
      const d = new Date(ts);
      return d.toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
    }catch(e){ return ts; }
  }
  const __geoSuccess = (typeof geoSuccess === 'function') ? geoSuccess : null;
  function geoSuccess(pos){
    if(!__geoSuccess) return;
    __geoSuccess(pos);
    try{
      const tEl = document.getElementById('geoTime');
      if(tEl && pos.timestamp){ tEl.value = formatJST(pos.timestamp); }
    }catch(e){}
  }


// expose latched levels for other scripts
try{
  window.getLatchedLevels = () => ({ A: lastALatched, B: lastBLatched, C: lastCLatched });
}catch(e){}
})();</script>

<script>
(function(){
  // --- 安全なロガーに置換（座標OFFでも記録する） ---
  const geoLat = document.getElementById('geoLat');
  const geoLon = document.getElementById('geoLon');
  const geoAcc = document.getElementById('geoAcc');
  const geoSpd = document.getElementById('geoSpd');
  const geoHead= document.getElementById('geoHead');
  const geoStatus = document.getElementById('geoStatus');
  const chkAttachLoc = document.getElementById('chkAttachLoc');
  const btnExportCSV = document.getElementById('btnExportCSV');

  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  const btnManualLog = document.getElementById('btnManualLog');

  const chkAutoSpaLog = document.getElementById('chkAutoSpaLog');
  const inpSpaLevelThresh = document.getElementById('inpSpaLevelThresh');
  const logNote = document.getElementById('logNote');

  // 既存 eventLog を利用 or 作成
  // persistent event log (localStorage)
function loadEventLog(){
  try{
    const s = localStorage.getItem('spa_event_log');
    if(!s) return [];
    const arr = JSON.parse(s);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function saveEventLog(){
  try{
    localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[]));
  }catch(e){}
}
window.eventLog = loadEventLog();

  function formatJST(ts){
    try{
      const d = new Date(ts);
      return d.toLocaleString('ja-JP', {
        timeZone: 'Asia/Tokyo',
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit'
      });
    }catch(e){ return String(ts); }
  }
  function nowJST(){ return formatJST(Date.now()); }

  function readGPS(){
    const pf=v=>{ const x=parseFloat(v); return Number.isFinite(x)? x : null; };
    return {
      lat: pf(geoLat?.value), lon: pf(geoLon?.value), acc: pf(geoAcc?.value),
      spd: pf(geoSpd?.value), head: pf(geoHead?.value)
    };
  }

  // 元の関数名 logEvent を安全版で上書き
  function (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM()){
  function num(txt){ const v=parseFloat((txt||'').replace(/[^\d\.\-]/g,'')); return (isFinite(v)? v : null); }
  const A = num((document.getElementById('kpiLevelA')||{}).textContent || '');
  const B = num((document.getElementById('kpiLevelB')||{}).textContent || '');
  const C = num((document.getElementById('kpiLevelC')||{}).textContent || '');
  return {A, B, C};
}
window.logEvent = function(kind, meta={}){
  const includeLoc = !!(chkAttachLoc && chkAttachLoc.checked);
  const includePlace = !!(chkIncludePlace && chkIncludePlace.checked);

  // Read A/B/C
  let levelA = null, levelB = null, levelC = null;
  try {
    const lv = (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM());
    levelA = (typeof meta.levelA === 'number' && isFinite(meta.levelA)) ? meta.levelA : (isFinite(lv.A)? lv.A : null);
    levelB = (typeof meta.levelB === 'number' && isFinite(meta.levelB)) ? meta.levelB : (isFinite(lv.B)? lv.B : null);
    levelC = (typeof meta.levelC === 'number' && isFinite(meta.levelC)) ? meta.levelC : (isFinite(lv.C)? lv.C : null);
  } catch(e){}

  const gps = includeLoc ? readGPS() : {lat:null,lon:null,acc:null,spd:null,head:null};
  const rec = {
    timeISO: nowJST(),
    epoch: Date.now(),
    type: kind,
    levelA, levelB, levelC,
    level: (typeof meta.level === 'number') ? meta.level
          : (typeof meta.spa === 'number' ? (meta.spa*2.44) : (levelC ?? levelB ?? levelA ?? null)),
    spa:   (typeof meta.spa === 'number') ? meta.spa : null,
    p:     (typeof meta.p   === 'number') ? meta.p   : null,
    lat: gps.lat, lon: gps.lon, acc: gps.acc, spd: gps.spd, head: gps.head,
    place: includePlace ? ((meta.place!=null? meta.place : (placeNameEl? placeNameEl.value : '')) || '') : '',
    note:  (meta.note!=null? meta.note : (placeMemoEl? placeMemoEl.value : '')) || ''
  };
  window.eventLog.push(rec); saveEventLog();
  try{ saveEventLog(); }catch(e){}
  try{ if(geoStatus) geoStatus.textContent='記録: ' + kind; }catch(e){}
};
    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind,
      level: (typeof meta.level === 'number') ? meta.level : null,
      spa:   (typeof meta.spa   === 'number') ? meta.spa   : null,
      p:     (typeof meta.p     === 'number') ? meta.p     : null,
      lat: gps.lat, lon: gps.lon, acc: gps.acc, spd: gps.spd, head: gps.head,
      place: includePlace ? ((meta.place!=null? meta.place : (placeNameEl? placeNameEl.value : '')) || '') : '',
      note:  (meta.note!=null? meta.note : (placeMemoEl? placeMemoEl.value : '')) || ''
    };
    window.eventLog.push(rec); saveEventLog();
    try{ if(geoStatus) geoStatus.textContent='記録: ' + kind; }catch(e){}
  };

  // CSV 出力ヘッダ（place, note を含める）
  function exportCSV(){
    if(!window.eventLog.length){
      try{ if(geoStatus) geoStatus.textContent='CSV対象のイベントがありません'; }catch(e){}
      return;
    }
    const header = ['timeISO','epoch','type','level','spa','p','lat','lon','acc','spd','head','place','note'];
    const lines = [header.join(',')].concat(
      window.eventLog.map(r => header.map(k => (r[k]==null? '' : r[k])).join(','))
    );
    const blob = new Blob([lines.join('\\n')], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'spa_events_jst.csv';
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    try{ if(geoStatus) geoStatus.textContent='CSVを書き出しました'; }catch(e){}
  }
  btnExportCSV && btnExportCSV.addEventListener('click', exportCSV);

  // 手動記録ボタン：現在の表示（kpi）からSPA/p取得
  btnManualLog && btnManualLog.addEventListener('click', ()=>{
    const spa = parseFloat((document.getElementById('kpiSPA')||{}).textContent||'');
    const p   = parseFloat((document.getElementById('kpiP')||{}).textContent||'');
    window.logEvent('manual', { spa: Number.isFinite(spa)? spa:null, p: Number.isFinite(p)? p:null });
  });

  // 自動記録：SPAレベル >= しきい値（デフォルト2.1）を1秒ごと監視、10秒デバウンス
  function readCurrentSPA(){
    const spa = parseFloat((document.getElementById('kpiSPA')||{}).textContent||'');
    const p   = parseFloat((document.getElementById('kpiP')||{}).textContent||'');
    const level = Number.isFinite(spa) ? (spa*2.44) : null;
    return { level, spa: Number.isFinite(spa)? spa:null, p: Number.isFinite(p)? p:null };
  }
  let lastAuto = 0;
  function autoTick(){
  if(!(chkAutoSpaLog && chkAutoSpaLog.checked)) return;
  const th = parseFloat(inpSpaLevelThresh?.value || '2.1');
  const target = (document.getElementById('selSpaLevelTarget')?.value || 'C');

  const lv = (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM());
  let curVal = null;
  if(target === 'A') curVal = lv.A;
  else if(target === 'B') curVal = lv.B;
  else curVal = lv.C;

  if(curVal!=null && curVal >= th){
    const now = Date.now();
    if(now - lastAuto > 10000){ // 10s debounce
      lastAuto = now;
      window.logEvent('level', { 
        levelA: lv.A,
        levelB: lv.B,
        levelC: lv.C,
        note: (logNote?.value || '')
      });
    }
  }
});
      }
    }
  }
  setInterval(autoTick, 1000);
})();
</script>


<script>
(function(){
  // --- Ensure level & place are always present in records ---
  function formatJST(ts){
    const d = new Date(ts);
    return d.toLocaleString('ja-JP', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
  }
  const placeNameEl = document.getElementById('placeName');
  const placeMemoEl = document.getElementById('placeMemo');
  const chkIncludePlace = document.getElementById('chkIncludePlace');
  // wrap push to fill level/time/place if missing
  (function enforceRecordShape(){
    const _push = Array.prototype.push;
    if(!window.eventLog) window.eventLog = [];
    // monkey patch eventLog.push to normalize records
    if(!window.eventLog.__patched){
      window.eventLog.push = function(){
        for(let i=0;i<arguments.length;i++){
          const r = arguments[i] || {};
          // time: JST string
          if(!r.timeISO){ r.timeISO = formatJST(Date.now()); }
          // level: prefer given; else compute from spa; else compute from UI
          if(typeof r.level !== 'number' || !isFinite(r.level)){
            let spa = r.spa;
            if(!(typeof spa === 'number' && isFinite(spa))){
              const sTxt = (document.getElementById('kpiSPA')||{}).textContent || '';
              const s = parseFloat(sTxt);
              spa = isFinite(s) ? s : null;
            }
            if(typeof spa === 'number' && isFinite(spa)) r.level = spa * 2.44;
          }
          // place: respect checkbox; fallback to input
          if(!('place' in r)){
            const include = !!(chkIncludePlace && chkIncludePlace.checked);
            r.place = include ? ((placeNameEl && placeNameEl.value) || '') : '';
          }
          arguments[i] = r;
        }
        return _push.apply(this, arguments);
      };
      Object.defineProperty(window.eventLog, '__patched', {value:true});
    }
  })();

  // --- Replace the CSV export button to output only [place, time, level] ---
  const btn = document.getElementById('btnExportCSV');
  if(btn){
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn); // remove old listeners
    clone.addEventListener('click', function(){
      if(!window.eventLog || !window.eventLog.length){
        const geoStatus = document.getElementById('geoStatus');
        if(geoStatus) geoStatus.textContent = 'CSV対象のイベントがありません';
        return;
      }
      const header = ['place','time','level'];
      const rows = [header.join(',')].concat(
        window.eventLog.map(r => {
          const place = r.place != null ? String(r.place) : '';
          const time  = r.timeISO != null ? String(r.timeISO) : formatJST(Date.now());
          const lvl   = (typeof r.level === 'number' && isFinite(r.level)) ? r.level.toFixed(2) : '';
          return [place, time, lvl].join(',');
        })
      );
      const blob = new Blob([rows.join('\\n')], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_events_place_time_level_jst.csv';
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
      const geoStatus = document.getElementById('geoStatus');
      if(geoStatus) geoStatus.textContent = 'CSV（場所,時間,レベル）を出力しました';
    });
  }
})();
</script>


<script>
// --- Robust CSV exporter: UTF-8 BOM, CRLF, columns = 場所,日付,時間,SPAレベルA,B,C ---
(function(){
  function csvEscape(v){
    if(v==null) return '';
    const s = String(v);
    return /[",\r\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  }
  function ensureTimeString(rec){
    if (rec && rec.timeISO) return String(rec.timeISO); // "YYYY/MM/DD HH:MM:SS" (JST)
    const d = new Date();
    return d.toLocaleString('ja-JP', {
      timeZone: 'Asia/Tokyo',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit'
    });
  }
  function splitDateTime(jstStr){
    const m = String(jstStr).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/);
    if (m) return { date: m[1], time: m[2] };
    const parts = String(jstStr).split(' ');
    return { date: parts[0] || '', time: parts[1] || '' };
  }
  function ensurePlace(rec){
    if (rec && rec.place!=null) return String(rec.place);
    const el = document.getElementById('placeName');
    const chk = document.getElementById('chkIncludePlace');
    return (chk && chk.checked && el) ? String(el.value||'') : '';
  }
  function fmtA(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtB(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(1) : ''; }
  function fmtC(v){ return (typeof v==='number' && isFinite(v)) ? v.toFixed(2) : ''; }

  const btn = document.getElementById('btnExportCSV');
  if(btn){
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(){
      const geoStatus = document.getElementById('geoStatus');
      const log = (window.eventLog && window.eventLog.length) ? window.eventLog.slice() : [];

      if(!log.length){
        // fallback: export one row of current snapshot (not saved to storage)
        const place = ensurePlace({});
        const jst   = ensureTimeString({});
        const dt = splitDateTime(jst);
        const lv = (typeof readLatchedLevelsFromDOM === 'function') ? (typeof window.getLatchedLevels==="function"? window.getLatchedLevels() : readLatchedLevelsFromDOM()) : {A:'',B:'',C:''};
        const a = fmtA(lv.A), b = fmtB(lv.B), c = fmtC(lv.C);
        const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
        const lines = [header.join(',')];
        lines.push([csvEscape(place), csvEscape(dt.date), csvEscape(dt.time), csvEscape(a), csvEscape(b), csvEscape(c)].join(','));
        const csvStr = '\ufeff' + lines.join('\r\n');
        const blob = new Blob([csvStr], {type:'text/csv;charset=utf-8;'});
        const aTag = document.createElement('a');
        aTag.href = URL.createObjectURL(blob);
        aTag.download = 'spa_場所_日付_時間_レベルABC.csv';
        document.body.appendChild(aTag); aTag.click();
        setTimeout(()=>{ URL.revokeObjectURL(aTag.href); aTag.remove(); }, 100);
        if(geoStatus) geoStatus.textContent = 'CSV（救済）現在値1行を出力しました';
        return;
      }

      log.sort((a,b)=>{
        const ea = (typeof a.epoch==='number')? a.epoch : 0;
        const eb = (typeof b.epoch==='number')? b.epoch : 0;
        return ea - eb;
      });

      const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
      const lines = [header.join(',')];
      for(const r of log){
        const place = ensurePlace(r);
        const jst   = ensureTimeString(r);
        const dt = splitDateTime(jst);
        const a = fmtA(r.levelA);
        const b = fmtB(r.levelB);
        const c = fmtC(r.levelC);
        lines.push([csvEscape(place), csvEscape(dt.date), csvEscape(dt.time), csvEscape(a), csvEscape(b), csvEscape(c)].join(','));
      }
      const csvStr = '\ufeff' + lines.join('\r\n');
      const blob = new Blob([csvStr], {type:'text/csv;charset=utf-8;'});
      const aTag = document.createElement('a');
      aTag.href = URL.createObjectURL(blob);
      aTag.download = 'spa_場所_日付_時間_レベルABC.csv';
      document.body.appendChild(aTag); aTag.click();
      setTimeout(()=>{ URL.revokeObjectURL(aTag.href); aTag.remove(); }, 100);
      if(geoStatus) geoStatus.textContent = 'CSV（場所,日付,時間,SPAレベルA,B,C）を出力しました';
    });
  }
})();
</script>


<script>
// ---- Fresh-start stabilizer (prevents first-frame jump after long idle open) ----
(function(){
  function safe(fn){ try{ fn && fn(); }catch(e){} }
  function clearCanvas(id){
    var c = document.getElementById(id);
    if(!c) return;
    var ctx = c.getContext && c.getContext('2d');
    if(!ctx) return;
    ctx.clearRect(0,0,c.width||c.clientWidth||0,c.height||c.clientHeight||0);
  }
  function resetArrays(names){
    names.forEach(function(n){
      if(window[n] && Array.isArray(window[n])){
        window[n].length = 0;
      }
    });
  }
  function resetNumbers(names){
    names.forEach(function(n){
      if(n in window){
        try{ window[n]=0; }catch(e){}
      }
    });
  }
  function prepareFreshStart(){
    // establish a time base and warm-up horizon
    var now = (performance && performance.now)? performance.now() : Date.now();
    window.__spaFreshStartAt = now;
    window.__spaWarmupUntil = now + 250; // ignore oversized dt for first 250ms
    window.__spaStartSeq = (window.__spaStartSeq||0) + 1;

    // likely data arrays used in this app (reset if present)
    resetArrays(['spaVals','pVals','meanBuf','mean5s','ydata','ybuf','ringP','ringSPA']);
    resetNumbers(['x','writeIdx','accum','lastTs','lastDrawTs','drift','driftEst']);

    // clear KPI text (optional)
    safe(function(){ var el=document.getElementById('kpiSPA'); if(el) el.textContent=''; });
    safe(function(){ var el=document.getElementById('kpiP'); if(el) el.textContent=''; });
    safe(function(){ var el=document.getElementById('kpiLevel'); if(el) el.textContent=''; });

    // clear canvases
    clearCanvas('bg');
    clearCanvas('fg');

    // resume audio if needed
    safe(function(){
      var AC = window.AC || window.audioCtx || window.audioContext;
      if(AC && AC.state==='suspended' && AC.resume) { AC.resume(); }
    });
  }

  // Clamp large dt on first frames by wrapping requestAnimationFrame during warm-up
  (function(){
    var _raf = window.requestAnimationFrame;
    if(!_raf || window.__rafPatched) return;
    window.requestAnimationFrame = function(cb){
      return _raf(function(t){
        try{
          if(window.__spaWarmupUntil && performance && performance.now){
            var now = performance.now();
            // expose a hint that downstream code may use
            window.__spaIsWarming = now < window.__spaWarmupUntil;
          }
        }catch(e){}
        cb(t);
      });
    };
    window.__rafPatched = true;
  })();

  // Ensure our reset runs BEFORE the app's own click handler using capture phase
  var btn = document.getElementById('btnStart');
  if(btn){
    btn.addEventListener('click', function(evt){
      prepareFreshStart();
    }, true); // capture
  }
})();
</script>


<script>
// --- FINAL OVERRIDE: 音量＆周波数を「どれだけ大きく超えたか」で動的制御 ---
// 既存の dynBeep(kind) を上書きします。既存呼び出し側の変更は不要です。
(function(){
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  // レベル推定（優先順：引数mag -> lastDisplay.level -> |z| -> 1）
  function estimateLevel(kind, mag){
    if(typeof mag === 'number' && isFinite(mag)) return mag;
    // UIラッチ表示から
    if(window.lastDisplay && typeof lastDisplay.level === 'number' && isFinite(lastDisplay.level)){
      return lastDisplay.level;
    }
    // 生zが取れるなら使う（2σ用に直感的）
    try{
      const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
      if(st && typeof st.mean==='number' && typeof st.std==='number' && st.std>0){
        const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
        const z = Math.abs((x - st.mean)/st.std);
        return z * 2.44; // zをレベル相当に換算（おおよそ）
      }
    }catch(e){}
    return 1; // フォールバック
  }
  window.dynBeep = function(kind="th", mag){
    if(!audioReady || (selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}
    const now = AC.currentTime;
    const mast = masterGain;

    // 基準周波数（従来：閾値880Hz / 2σ1320Hz）
    const base = (kind==="z") ? 1320 : 880;

    // レベル推定 → 音量・周波数スケーリング
    const level = estimateLevel(kind, mag);              // 例：1.3, 2.5, 4.0...
    const vol   = clamp(0.06 + (level-1)*0.10, 0.05, 1); // レベル1→0.06、以後+0.10/レベル（上限1）
    const freq  = base + (level-1)*160;                  // レベル1→base、以後+160Hz/レベル

    // オシレータを短いエンベロープで鳴らす（kindで長さ微調整）
    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(freq, now);

    // クリックノイズを抑えるエンベロープ（AR）
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    o.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);
  };
})();
</script>

<script>
// --- FINAL OVERRIDE (UI sliders & defaults) ---
(function(){
  function $(id){ return document.getElementById(id); }
  const volScaleEl = $('rngVolScale');
  const pitchStepEl = $('rngPitchStep');
  const volMaxEl = $('rngVolMax');
  const lblVolScale = $('lblVolScale');
  const lblPitchStep = $('lblPitchStep');
  const lblVolMax = $('lblVolMax');

  function updLabels(){
    if(lblVolScale && volScaleEl) lblVolScale.textContent = (parseFloat(volScaleEl.value)||1).toFixed(2) + '×';
    if(lblPitchStep && pitchStepEl) lblPitchStep.textContent = (parseFloat(pitchStepEl.value)||160).toFixed(0) + ' Hz/level';
    if(lblVolMax && volMaxEl) lblVolMax.textContent = (parseFloat(volMaxEl.value)||1).toFixed(2);
  }
  ['input','change'].forEach(ev=>{
    volScaleEl && volScaleEl.addEventListener(ev, updLabels);
    pitchStepEl && pitchStepEl.addEventListener(ev, updLabels);
    volMaxEl && volMaxEl.addEventListener(ev, updLabels);
  });
  updLabels();

  // デフォルト値の設定：ドリフト α=0.05、SPAレベル自動記録=1.5
  try{
    const alphaInput = document.getElementById('inpAlpha') || document.querySelector('[name="alpha"]');
    if(alphaInput){ alphaInput.value = 0.05; }
    if(window.alpha !== undefined){ window.alpha = 0.05; }
  }catch(e){}
  try{
    const autoLevel = document.getElementById('inpSpaLevelThresh');
    if(autoLevel){ autoLevel.value = 1.5; }
    if(window.autoRecordLevel !== undefined){ window.autoRecordLevel = 1.5; }
  }catch(e){}

  // しきい値が内部で参照される型なら、保存/反映フローがあれば呼ぶ
  try{
    if(typeof applyParams==='function') applyParams();
  }catch(e){}

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function estimateLevel(kind, mag){
    if(typeof mag === 'number' && isFinite(mag)) return mag;
    if(window.lastDisplay && typeof lastDisplay.level === 'number' && isFinite(lastDisplay.level)){
      return lastDisplay.level;
    }
    try{
      const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
      if(st && typeof st.mean==='number' && typeof st.std==='number' && st.std>0){
        const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
        const z = Math.abs((x - st.mean)/st.std);
        return z * 2.44;
      }
    }catch(e){}
    return 1;
  }

  // dynBeepを再オーバーライドしてスライダの値を反映
  window.dynBeep = function(kind="th", mag){
    if(!window.audioReady || (window.selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}
    const now = AC.currentTime;
    const mast = masterGain;

    const base = (kind==="z") ? 1320 : 880;
    const level = estimateLevel(kind, mag);

    const volBase = 0.06 + (level-1)*0.10;
    const volScale = volScaleEl ? parseFloat(volScaleEl.value) || 1 : 1;
    const volMax = volMaxEl ? parseFloat(volMaxEl.value) || 1 : 1;
    const vol = clamp(volBase * volScale, 0.01, volMax);

    const step = pitchStepEl ? parseFloat(pitchStepEl.value) || 160 : 160;
    const freq = base + (level-1)*step;

    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;

    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = "sine";
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    o.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);
  };
})();
</script>

<style>
#fxFlash{
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at center, rgba(255,60,60,0.35), rgba(255,0,0,0.0) 60%);
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease-out;
  mix-blend-mode: screen;
  z-index: 9999;
}
</style>
<style>
#fxFlash.white { background: rgba(255,255,255,0.9) !important; mix-blend-mode: screen; }
#fxFlash.red { background: radial-gradient(ellipse at center, rgba(255,60,60,0.35), rgba(255,0,0,0.0) 60%) !important; }
#fxFlash.blue { background: radial-gradient(ellipse at center, rgba(60,160,255,0.35), rgba(0,80,255,0.0) 60%) !important; }
</style>

<div id="fxFlash"></div>

<script>
// --- FINAL OVERRIDE: 強演出プリセット & フラッシュ/バイブ連動 ---
(function(){
  function $(id){ return document.getElementById(id); }
  const volScaleEl = $('rngVolScale');
  const pitchStepEl = $('rngPitchStep');
  const volMaxEl = $('rngVolMax');
  const btnQuiet = $('btnPresetQuiet');
  const btnNormal = $('btnPresetNormal');
  const btnStrong = $('btnPresetStrong');
  const flash = $('fxFlash');
  const chkStrongFX = $('chkStrongFX');

  function applyPreset(name){
    if(name==='quiet'){
      if(volScaleEl) volScaleEl.value = 0.6;
      if(pitchStepEl) pitchStepEl.value = 120;
      if(volMaxEl) volMaxEl.value = 0.4;
    }else if(name==='normal'){
      if(volScaleEl) volScaleEl.value = 1.0;
      if(pitchStepEl) pitchStepEl.value = 160;
      if(volMaxEl) volMaxEl.value = 1.0;
    }else if(name==='strong'){
      if(volScaleEl) volScaleEl.value = 2.2;
      if(pitchStepEl) pitchStepEl.value = 300;
      if(volMaxEl) volMaxEl.value = 1.0;
      if(chkStrongFX) chkStrongFX.checked = true;
    }
    // fire input events so labels update if any
    ['input','change'].forEach(ev=>{
      volScaleEl && volScaleEl.dispatchEvent(new Event(ev));
      pitchStepEl && pitchStepEl.dispatchEvent(new Event(ev));
      volMaxEl && volMaxEl.dispatchEvent(new Event(ev));
    });
  }
  btnQuiet && btnQuiet.addEventListener('click', ()=>applyPreset('quiet'));
  btnNormal && btnNormal.addEventListener('click', ()=>applyPreset('normal'));
  btnStrong && btnStrong.addEventListener('click', ()=>applyPreset('strong'));

  // Visual flash & vibration helpers
  function flashFX(intensity){
    if(!flash || !chkStrongFX || !chkStrongFX.checked) return;
    const op = Math.max(0, Math.min(1, 0.25 + intensity*0.15)); // 0.25..1.0
    flash.style.opacity = op;
    setTimeout(()=>{ flash.style.opacity = 0; }, 180);
  }
  function vibrateFX(level){
    if(!chkStrongFX || !chkStrongFX.checked) return;
    if(navigator.vibrate){
      const ms = Math.max(40, Math.min(400, 60 + (level-1)*80));
      navigator.vibrate(ms);
    }
  }

  // Hook into dynBeep to add FX & (optionally) burst for strong events
  const origDynBeep = window.dynBeep;
  window.dynBeep = function(kind="th", mag){
    // call original to play sound (which reads sliders)
    try{ origDynBeep && origDynBeep(kind, mag); }catch(e){}

    // estimate "level" for FX intensity
    let level = 1;
    try{
      if(typeof mag === 'number' && isFinite(mag)) level = mag;
      else if(window.lastDisplay && isFinite(lastDisplay.level)) level = lastDisplay.level;
      else{
        const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
        if(st && st.std>0){
          const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
          const z = Math.abs((x - st.mean)/st.std);
          level = z*2.44;
        }
      }
    }catch(e){}

    // strong FX
    flashFX(level);
    vibrateFX(level);

    // burst beeps for very strong events
    if(chkStrongFX && chkStrongFX.checked && level >= 3){
      setTimeout(()=>{ try{ origDynBeep && origDynBeep(kind, level+0.4); }catch(e){} }, 90);
      setTimeout(()=>{ try{ origDynBeep && origDynBeep(kind, level+0.7); }catch(e){} }, 190);
    }
  };

  // Optional: auto-apply "強演出" on load for convenience
  // applyPreset('strong'); // uncomment if you want default strong
})();
</script>

<script>
// --- FINAL OVERRIDE: 波形/歪み/フラッシュ様式 + 自動強演出ON ---
(function(){
  function $(id){ return document.getElementById(id); }
  const selWave = $('selWave');
  const rngDist = $('rngDist');
  const lblDist = $('lblDist');
  const selFlash = $('selFlash');
  const chkAutoStrong = $('chkAutoStrong');
  const flash = $('fxFlash');

  function updDistLabel(){
    if(lblDist && rngDist) lblDist.textContent = String(parseInt(rngDist.value||'0',10));
  }
  ['input','change'].forEach(ev=>{ rngDist && rngDist.addEventListener(ev, updDistLabel); });
  updDistLabel();

  // Remember settings
  const LSKEY = 'spa_strong_preset_settings';
  function saveSettings(){
    try{
      const data = {
        wave: selWave ? selWave.value : 'sine',
        dist: rngDist ? parseInt(rngDist.value||'0',10) : 0,
        flash: selFlash ? selFlash.value : 'red',
        autoStrong: chkAutoStrong ? !!chkAutoStrong.checked : true
      };
      localStorage.setItem(LSKEY, JSON.stringify(data));
    }catch(e){}
  }
  function loadSettings(){
    try{
      const raw = localStorage.getItem(LSKEY);
      if(!raw) return;
      const data = JSON.parse(raw);
      if(selWave && data.wave) selWave.value = data.wave;
      if(rngDist && (data.dist!==undefined)) rngDist.value = data.dist;
      if(selFlash && data.flash) selFlash.value = data.flash;
      if(chkAutoStrong && (data.autoStrong!==undefined)) chkAutoStrong.checked = !!data.autoStrong;
      updDistLabel();
    }catch(e){}
  }
  ['input','change'].forEach(ev=>{
    selWave && selWave.addEventListener(ev, saveSettings);
    rngDist && rngDist.addEventListener(ev, saveSettings);
    selFlash && selFlash.addEventListener(ev, saveSettings);
    chkAutoStrong && chkAutoStrong.addEventListener(ev, saveSettings);
  });
  loadSettings();

  // Apply strong preset automatically if opted-in
  try{
    if(chkAutoStrong && chkAutoStrong.checked && typeof applyPreset==='function'){
      // apply strong after UI is ready
      setTimeout(()=>{ try{ applyPreset('strong'); }catch(e){} }, 50);
    }
  }catch(e){}

  // Extend dynBeep to use waveform + optional waveshaper distortion
  const origDynBeep = window.dynBeep;
  window.dynBeep = function(kind="th", mag){
    if(!window.audioReady || (window.selAudio && selAudio.value==="off")) return;
    try{ ensureAudio(); }catch(e){}

    // Let the existing dynBeep compute timing, volume, and base connections,
    // but we'll rebuild the audio graph here to insert waveshaper.
    // We'll replicate the volume & pitch calculations by temporarily calling the original and intercepting not possible,
    // so we redo minimal logic by reading UI from previous override:
    const now = AC.currentTime;
    const mast = masterGain;

    // Reuse estimateLevel logic if available:
    let level = 1;
    try{
      if(typeof mag === 'number' && isFinite(mag)) level = mag;
      else if(window.lastDisplay && isFinite(lastDisplay.level)) level = lastDisplay.level;
      else{
        const st = (typeof rollingStatsFast==='function') ? rollingStatsFast() : null;
        if(st && st.std>0){
          const x = getAt(Math.max(0, (typeof N==='number'?N:1)-1));
          const z = Math.abs((x - st.mean)/st.std);
          level = z*2.44;
        }
      }
    }catch(e){}

    const base = (kind==="z") ? 1320 : 880;
    // Sliders from previous UI (if exist)
    const volScaleEl = document.getElementById('rngVolScale');
    const pitchStepEl = document.getElementById('rngPitchStep');
    const volMaxEl = document.getElementById('rngVolMax');
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
    const volBase = 0.06 + (level-1)*0.10;
    const volScale = volScaleEl ? parseFloat(volScaleEl.value) || 1 : 1;
    const volMax = volMaxEl ? parseFloat(volMaxEl.value) || 1 : 1;
    const vol = clamp(volBase * volScale, 0.01, volMax);
    const step = pitchStepEl ? parseFloat(pitchStepEl.value) || 160 : 160;
    const freq = base + (level-1)*step;
    const dur = (kind==="z") ? 0.22 + (level-1)*0.06 : 0.12 + (level-1)*0.04;

    // Build audio graph: Oscillator -> [WaveShaper?] -> Gain -> master
    const o = AC.createOscillator();
    o.type = (selWave && selWave.value) || 'sine';
    o.frequency.setValueAtTime(freq, now);

    let nodeChainOut = o;
    // optional distortion
    const distAmt = rngDist ? parseInt(rngDist.value||'0',10) : 0;
    if(distAmt > 0){
      const ws = AC.createWaveShaper();
      // create simple curve: arctangent style
      const n=1024; const curve = new Float32Array(n);
      const k = distAmt; // 0..40
      for(let i=0;i<n;i++){
        const x = (i/(n-1))*2 - 1;
        curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
      }
      ws.curve = curve; ws.oversample = '4x';
      nodeChainOut.connect(ws); nodeChainOut = ws;
    }

    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    nodeChainOut.connect(g); g.connect(mast);
    o.start(now); o.stop(now + dur + 0.02);

    // Flash style
    if(flash){
      flash.classList.remove('white','red','blue');
      const style = (selFlash && selFlash.value) || 'red';
      flash.classList.add(style);
      const opBase = (style==='white') ? 0.7 : 0.25;
      const op = Math.max(0, Math.min(1, opBase + level*0.15));
      flash.style.opacity = op;
      setTimeout(()=>{ flash.style.opacity = 0; }, (style==='white') ? 120 : 180);
    }

    // Burst for strong events remains handled by prior override (if any)
    try{
      const chkStrongFX = document.getElementById('chkStrongFX');
      if(chkStrongFX && chkStrongFX.checked && level >= 3){
        setTimeout(()=>{ try{ window.dynBeep && origDynBeep && origDynBeep(kind, level+0.4); }catch(e){} }, 90);
        setTimeout(()=>{ try{ window.dynBeep && origDynBeep && origDynBeep(kind, level+0.7); }catch(e){} }, 190);
      }
    }catch(e){}
  };
})();
</script>

<script>
(function(){
  const btnTestFlash = document.getElementById('btnTestFlash');
  const flash = document.getElementById('fxFlash');
  const selFlash = document.getElementById('selFlash');
  if(btnTestFlash && flash){
    btnTestFlash.addEventListener('click', ()=>{
      flash.classList.remove('white','red','blue');
      const style = (selFlash && selFlash.value) || 'red';
      flash.classList.add(style);
      flash.style.opacity = 1;
      setTimeout(()=>{ flash.style.opacity = 0; }, (style==='white')?120:180);
    });
  }
})();
</script>

<script>
// ===== Sampling Rate Slider Wiring =====
(function(){
  // Desired global hooks:
  // - A function stopScan() that clears intervals/RAF if present
  // - A function startScan() that starts the main loop using current interval
  // If they don't exist, we will wrap the existing loop.

  // Expose/initialize globals
  window.__spaSamplingHz = 10;         // default Hz
  window.__spaSamplingIntervalMs = 100;
  window.__spaScanTimer = null;
  window.__spaUseRAF = false; // set true if your main loop uses requestAnimationFrame

  // Find slider
  const rate = document.getElementById('samplingRate');
  const lblHz = document.getElementById('samplingRateLabel');
  const lblMs = document.getElementById('samplingIntervalLabel');

  function applySampling(hz){
    hz = Math.max(5, Math.min(120, Math.round(hz)));
    window.__spaSamplingHz = hz;
    window.__spaSamplingIntervalMs = Math.max(1, Math.round(1000 / hz));
    if (lblHz) lblHz.textContent = hz.toString();
    if (lblMs) lblMs.textContent = window.__spaSamplingIntervalMs.toString();
  }
  applySampling(rate ? parseInt(rate.value,10) : 10);

  // Try to detect existing scan loop starter
  // We look for a start button with id-like 'btnScan' or text 'スキャン実行' to hook restart
  function restartScanIfRunning(){
    // If timer running, restart with new interval
    if (window.__spaScanTimer){
      if (window.__spaUseRAF && window.cancelAnimationFrame){
        cancelAnimationFrame(window.__spaScanTimer);
      }else{
        clearInterval(window.__spaScanTimer);
      }
      window.__spaScanTimer = null;
      if (typeof window.__spaMainStep === 'function'){
        // Start with new interval
        if (window.__spaUseRAF){
          const loop = ()=>{ window.__spaMainStep(); window.__spaScanTimer = requestAnimationFrame(loop); };
          window.__spaScanTimer = requestAnimationFrame(loop);
        }else{
          window.__spaScanTimer = setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
        }
      }
    }
  }

  if (rate){
    rate.addEventListener('input', (e)=>{
      applySampling(parseInt(rate.value,10));
      restartScanIfRunning();
    });
  }

  // ---- Wrapping existing logic ----
  // We attempt to hook the app's main step function. If your code calls setInterval(mainStep, X),
  // define window.__spaMainStep = mainStep and use our timer.
  // Below, we monkey-patch setInterval to capture main loop if possible (best-effort, non-breaking).
  (function(){
    const _setInterval = window.setInterval;
    window.setInterval = function(fn, ms, ...rest){
      // Heuristic: if interval is between 10ms and 1000ms and function name looks like a main loop,
      // we capture it as __spaMainStep and drive it ourselves.
      try{
        if (typeof fn === 'function' && ms >= 10 && ms <= 1000 && !window.__spaMainStep){
          // Register main step
          window.__spaMainStep = fn;
          // Use our own interval based on slider
          const t = _setInterval(()=>{}, 1); clearInterval(t); // noop to keep behavior similar
          // Start our timer if not already
          if (!window.__spaScanTimer){
            applySampling(window.__spaSamplingHz);
            window.__spaScanTimer = _setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
          }
          return window.__spaScanTimer;
        }
      }catch(e){ /* fallthrough */ }
      return _setInterval(fn, ms, ...rest);
    };
    const _clearInterval = window.clearInterval;
    window.clearInterval = function(id){
      if (id === window.__spaScanTimer){
        window.__spaScanTimer = null;
      }
      return _clearInterval(id);
    };
  })();

  // Optional: expose manual controls
  window.__spaStopScan = function(){
    if (window.__spaScanTimer){
      if (window.__spaUseRAF && window.cancelAnimationFrame){
        cancelAnimationFrame(window.__spaScanTimer);
      }else{
        clearInterval(window.__spaScanTimer);
      }
      window.__spaScanTimer = null;
    }
  };
  window.__spaStartScan = function(){
    if (window.__spaScanTimer || typeof window.__spaMainStep !== 'function') return;
    if (window.__spaUseRAF){
      const loop = ()=>{ window.__spaMainStep(); window.__spaScanTimer = requestAnimationFrame(loop); };
      window.__spaScanTimer = requestAnimationFrame(loop);
    }else{
      window.__spaScanTimer = setInterval(window.__spaMainStep, window.__spaSamplingIntervalMs);
    }
  };

  // If your app uses requestAnimationFrame, set:
  // window.__spaUseRAF = true; before calling __spaStartScan().
})();
</script>


<script>
// ===== Windowed/Cumulative Frequency (超え率) =====
(function(){
  // 状態
  window.__freqMode = 'window'; // 'cumulative' or 'window'
  window.__freqWindowSec = 1;
  window.__freqNowLabel = null;
  window.__freqModeLabel = null;
  window.__freqResetBtn = null;
  window.__freqWindowBuf = []; // booleans
  window.__freqBufMax = 0;
  window.__freqBufIdx = 0;
  window.__freqBufFilled = 0;
  window.__freqK_cum = 0;
  window.__freqN_cum = 0;
  window.__spaCurrentStepOver = false;

  function el(id){ return document.getElementById(id); }

  function updateBufSize(){
    const hz = window.__spaSamplingHz || 10;
    window.__freqBufMax = Math.max(1, Math.round(hz * window.__freqWindowSec));
    if (window.__freqWindowBuf.length !== window.__freqBufMax){
      window.__freqWindowBuf = new Array(window.__freqBufMax).fill(false);
      window.__freqBufIdx = 0;
      window.__freqBufFilled = 0;
    }
  }

  function resetWindow(){
    window.__freqWindowBuf.fill(false);
    window.__freqBufIdx = 0;
    window.__freqBufFilled = 0;
  }
  function resetCumulative(){
    window.__freqK_cum = 0;
    window.__freqN_cum = 0;
  }

  // UI wiring
  function initUI(){
    window.__freqNowLabel = el('freqNowLabel');
    window.__freqModeLabel = el('freqModeLabel');
    window.__freqResetBtn = el('freqResetBtn');
    const winSec = el('freqWindowSec');
    const radios = document.querySelectorAll('input[name="freqMode"]');

    radios.forEach(r=>{
      r.addEventListener('change', ()=>{
        window.__freqMode = r.value;
        if (window.__freqModeLabel) window.__freqModeLabel.textContent = (r.value === 'window') ? '区間' : '累積';
        if (r.value === 'window'){ resetWindow(); }
        else { resetCumulative(); }
        updateBufSize();
      });
    });

    if (winSec){
      winSec.addEventListener('change', ()=>{
        const v = Math.max(1, Math.min(30, parseInt(winSec.value||'1',10)));
        winSec.value = v;
        window.__freqWindowSec = v;
        updateBufSize();
      });
    }

    if (window.__freqResetBtn){
      window.__freqResetBtn.addEventListener('click', ()=>{
        if (window.__freqMode === 'window') resetWindow(); else resetCumulative();
      });
    }

    // 初期設定
    window.__freqMode = 'window';
    window.__freqWindowSec = Math.max(1, parseInt(winSec ? winSec.value : '1', 10));
    if (window.__freqModeLabel) window.__freqModeLabel.textContent = '区間';
    updateBufSize();
  }

  // 統合：各ステップ前後でフラグを扱うため、__spaMainStep をラップ
  function installStepWrapper(){
    if (typeof window.__spaMainStep !== 'function') return;
    if (window.__wrappedMainStep) return; // double wrap防止
    const orig = window.__spaMainStep;
    window.__wrappedMainStep = function(){
      // ステップ開始：今ステップの超過フラグをfalseでクリア
      window.__spaCurrentStepOver = false;
      // 実行
      orig();
      // 実行後：超過フラグを集計
      // 区間モード
      if (window.__freqMode === 'window'){
        if (window.__freqBufMax <= 0) updateBufSize();
        const idx = window.__freqBufIdx;
        const prev = window.__freqWindowBuf[idx] ? 1 : 0;
        const cur = window.__spaCurrentStepOver ? 1 : 0;
        window.__freqWindowBuf[idx] = !!window.__spaCurrentStepOver;
        window.__freqBufIdx = (idx + 1) % window.__freqBufMax;
        if (window.__freqBufFilled < window.__freqBufMax) window.__freqBufFilled++;

        // 計算
        let K = 0;
        // 小規模なので単純合計
        for (let i=0;i<window.__freqBufFilled;i++){ if (window.__freqWindowBuf[i]) K++; }
        const N = window.__freqBufFilled;
        const p = (K + 1) / (N + 2);
        if (window.__freqNowLabel) window.__freqNowLabel.textContent = (p*100).toFixed(2) + '%';
      } else {
        // 累積モード
        window.__freqN_cum++;
        if (window.__spaCurrentStepOver) window.__freqK_cum++;
        const p = (window.__freqK_cum + 1) / (window.__freqN_cum + 2);
        if (window.__freqNowLabel) window.__freqNowLabel.textContent = (p*100).toFixed(2) + '%';
      }
    };
    window.__spaMainStep = window.__wrappedMainStep;
  }

  // dynBeep / logEvent をパッチして、そのステップで超過が起きたらフラグを立てる
  function patchTriggers(){
    const markOver = ()=>{ window.__spaCurrentStepOver = true; };
    // dynBeep
    const _dynBeep = window.dynBeep;
    window.dynBeep = function(){ try{ markOver(); }catch(e){}; return _dynBeep ? _dynBeep.apply(this, arguments) : undefined; };
    // logEvent
    const _logEvent = window.logEvent;
    window.logEvent = function(){ try{ markOver(); }catch(e){}; return _logEvent ? _logEvent.apply(this, arguments) : undefined; };
  }

  window.addEventListener('load', function(){
    try{
      initUI();
      patchTriggers();
      // install step wrapper once main step is known
      const intv = setInterval(()=>{
        if (typeof window.__spaMainStep === 'function'){
          installStepWrapper();
          clearInterval(intv);
        }
      }, 100);
    }catch(e){ console.warn('freq wiring error', e); }
  });
})();
</script>


<script>
(function(){
  if (window.__spa_csv_patch_applied2__) return;
  window.__spa_csv_patch_applied2__ = true;

  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function readLatchedLevelsFromDOM(){
    function numText(el){
      if(!el) return null;
      const t = (el.textContent||'').replace(/[^\d\.\-]/g,'');
      const v = parseFloat(t);
      return Number.isFinite(v) ? v : null;
    }
    return {
      A: numText(document.getElementById('kpiLevelA')),
      B: numText(document.getElementById('kpiLevelB')),
      C: numText(document.getElementById('kpiLevelC')),
    };
  }
  if (typeof window.getLatchedLevels !== 'function'){
    window.getLatchedLevels = function(){ return readLatchedLevelsFromDOM(); };
  }
  function loadEventLog(){
    try{ const s = localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; }
  }
  function saveEventLog(){ try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){} }
  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

  const originalLogEvent = window.logEvent;
  window.logEvent = function(kind, meta={}){
    let lv=null;
    try{ lv=(typeof window.getLatchedLevels==='function')?window.getLatchedLevels():readLatchedLevelsFromDOM(); }
    catch(_){ lv=readLatchedLevelsFromDOM(); }
    const levelA = Number.isFinite(meta.levelA) ? meta.levelA : (Number.isFinite(lv?.A) ? lv.A : null);
    const levelB = Number.isFinite(meta.levelB) ? meta.levelB : (Number.isFinite(lv?.B) ? lv.B : null);
    const levelC = Number.isFinite(meta.levelC) ? meta.levelC : (Number.isFinite(lv?.C) ? lv.C : null);
    const spa = Number.isFinite(meta.spa) ? meta.spa : null;
    const levelFallback = Number.isFinite(spa) ? spa*2.44 : (levelC ?? levelB ?? levelA ?? null);
    const get = id => document.getElementById(id);
    const includePlace = !!(get('chkIncludePlace')?.checked ?? true);
    const attachLoc = !!(get('chkAttachLoc')?.checked);
    const placeName = includePlace ? ((meta.place ?? (get('placeName')?.value) ?? '') + '') : '';
    const gps = attachLoc ? (function(){
      const pf = v => { const x=parseFloat(v); return Number.isFinite(x)?x:null; };
      return {lat:pf(get('geoLat')?.value), lon:pf(get('geoLon')?.value), acc:pf(get('geoAcc')?.value),
              spd:pf(get('geoSpd')?.value), head:pf(get('geoHead')?.value)};
    })() : {lat:null,lon:null,acc:null,spd:null,head:null};
    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind,
      levelA, levelB, levelC,
      level: Number.isFinite(meta.level) ? meta.level : levelFallback,
      spa: spa,
      p: Number.isFinite(meta.p) ? meta.p : null,
      ...gps,
      place: placeName,
      note:  (meta.note ?? (get('placeMemo')?.value) ?? '') + ''
    };
    try{ if (typeof originalLogEvent === 'function') originalLogEvent(kind, meta); }catch(_){}
    try{ window.eventLog.push(rec); saveEventLog(); }catch(_){}
    const st = get('geoStatus'); if(st) st.textContent = '記録: ' + kind + '（' + rec.timeISO + '）';
  };

  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSV(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ const st=document.getElementById('geoStatus'); if(st) st.textContent='CSV対象のイベントがありません'; return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC))
      ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    const st=document.getElementById('geoStatus'); if(st) st.textContent='CSVを書き出しました（場所,日付,時間,ABC）';
  }

  function bindClick(el){
    if(!el) return;
    el.style.pointerEvents = 'auto';
    el.style.userSelect = 'auto';
    el.removeAttribute('disabled');
    ['click','mousedown','touchstart'].forEach(evt=>{
      el.addEventListener(evt, function(ev){
        ev.preventDefault(); ev.stopPropagation();
        try{ exportCSV(); }catch(e){ console.error(e); }
      }, {passive:false});
    });
  }

  function install(){
    // 1) id優先
    var el = document.getElementById('btnExportCSV');
    if(el){ bindClick(el); }
    // 2) ラベル探索（"イベントCSV"を含むボタン/リンク）
    var nodes = Array.from(document.querySelectorAll('button, a, [role="button"]'));
    nodes.filter(n => (n.textContent||'').indexOf('イベントCSV') >= 0).forEach(bindClick);
    // 3) 予備ボタンを隣に注入
    if(el && !document.getElementById('btnExportCSV_fallback')){
      var fb = document.createElement('button');
      fb.id = 'btnExportCSV_fallback';
      fb.textContent = 'イベントCSV（予備）';
      fb.style.marginLeft = '8px';
      el.insertAdjacentElement('afterend', fb);
      bindClick(fb);
    }
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', install); } else { install(); }
})();
</script>

<script>
(function(){
  if (window.__spa_csv_hotfix__) return; window.__spa_csv_hotfix__=true;

  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSV(){
    try{
      const log = Array.isArray(window.eventLog) ? window.eventLog : [];
      if(!log.length){ const st=document.getElementById('geoStatus'); if(st) st.textContent='CSV対象のイベントがありません'; return; }
      const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
      const rows = [header.join(',')];
      for(const r of log){
        const dt = splitDateTime(r.timeISO ?? '');
        rows.push([
          csvEscape(r.place ?? ''),
          csvEscape(dt.date),
          csvEscape(dt.time),
          csvEscape(fmtA(r.levelA)),
          csvEscape(fmtB(r.levelB)),
          csvEscape(fmtC(r.levelC))
        ].join(','));
      }
      const bom = new Uint8Array([0xEF,0xBB,0xBF]);
      const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'spa_events_place_date_time_ABC.csv';
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
      const st=document.getElementById('geoStatus'); if(st) st.textContent='CSVを書き出しました（場所,日付,時間,ABC）';
    }catch(e){ console.error(e); }
  }

  function safeBind(el){
    if(!el || el.__csv_hotfix_bound) return;
    el.__csv_hotfix_bound = true;
    el.addEventListener('click', function(){
      // 1) 保存前のKPIテキストを控える
      const Ael = document.getElementById('kpiLevelA');
      const Bel = document.getElementById('kpiLevelB');
      const Cel = document.getElementById('kpiLevelC');
      const oldA = Ael ? Ael.textContent : null;
      const oldB = Bel ? Bel.textContent : null;
      const oldC = Cel ? Cel.textContent : null;

      // 2) CSVを書き出し
      exportCSV();

      // 3) 万一どこかで消えた場合に備えて元に戻す
      setTimeout(()=>{
        if(Ael && (!Ael.textContent || Ael.textContent.trim()==='—') && oldA) Ael.textContent = oldA;
        if(Bel && (!Bel.textContent || Bel.textContent.trim()==='—') && oldB) Bel.textContent = oldB;
        if(Cel && (!Cel.textContent || Cel.textContent.trim()==='—') && oldC) Cel.textContent = oldC;
      }, 50);
    }, {capture:false});
  }

  function init(){
    const idBtn = document.getElementById('btnExportCSV');
    if(idBtn) safeBind(idBtn);
    // テキストで検索（イベントCSV）— UIそのまま対応
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0)
      .forEach(safeBind);
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>

<script>
(function(){
  if (window.__spa_recorder_v3__) return; window.__spa_recorder_v3__=true;

  // ---------- helpers ----------
  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function numFromText(el){
    if(!el) return null;
    const t = (el.textContent||'').replace(/[^\d\.\-]/g,'');
    const v = parseFloat(t);
    return Number.isFinite(v) ? v : null;
  }
  function getLevels(){
    return {
      A: numFromText(document.getElementById('kpiLevelA')),
      B: numFromText(document.getElementById('kpiLevelB')),
      C: numFromText(document.getElementById('kpiLevelC')),
    };
  }
  function readGPS(){
    const g = id => document.getElementById(id);
    const pf = v => { const x = parseFloat(v); return Number.isFinite(x)?x:null; };
    return {
      lat: pf(g('geoLat')?.value), lon: pf(g('geoLon')?.value),
      acc: pf(g('geoAcc')?.value), spd: pf(g('geoSpd')?.value), head: pf(g('geoHead')?.value),
    };
  }
  function placeEnabled(){ const c = document.getElementById('chkIncludePlace'); return (c==null) ? true : !!c.checked; }
  function attachLoc(){ const c = document.getElementById('chkAttachLoc'); return !!(c&&c.checked); }
  function placeName(){ return placeEnabled() ? ((document.getElementById('placeName')?.value)||'') : ''; }
  function memoText(){ return (document.getElementById('placeMemo')?.value)||''; }
  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }

  // ---------- persistent log ----------
  function loadEventLog(){
    try{ const s=localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; }
  }
  function saveEventLog(){
    try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){}
  }
  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

  // ---------- unified logEvent ----------
  const prevLogEvent = window.logEvent;
  window.logEvent = function(kind, meta={}){
    // merge with current latched levels
    const lv = getLevels();
    const levelA = Number.isFinite(meta.levelA) ? meta.levelA : lv.A;
    const levelB = Number.isFinite(meta.levelB) ? meta.levelB : lv.B;
    const levelC = Number.isFinite(meta.levelC) ? meta.levelC : lv.C;
    const spa = Number.isFinite(meta.spa) ? meta.spa : null;
    const levelFallback = Number.isFinite(spa) ? spa*2.44 : (Number.isFinite(levelC)?levelC:Number.isFinite(levelB)?levelB:Number.isFinite(levelA)?levelA:null);

    const rec = {
      timeISO: nowJST(),
      epoch: Date.now(),
      type: kind||'manual',
      levelA: Number.isFinite(levelA)?levelA:null,
      levelB: Number.isFinite(levelB)?levelB:null,
      levelC: Number.isFinite(levelC)?levelC:null,
      level: Number.isFinite(meta.level)? meta.level : levelFallback,
      spa: spa,
      p: Number.isFinite(meta.p) ? meta.p : null,
      ...(attachLoc()? readGPS(): {lat:null,lon:null,acc:null,spd:null,head:null}),
      place: placeName(),
      note: (meta.note ?? memoText())+''
    };

    // push our log first (so even if the original throws, we keep data)
    try{ window.eventLog.push(rec); saveEventLog(); }catch(e){ console.warn('log push failed', e); }
    try{ if (typeof prevLogEvent === 'function') prevLogEvent(kind, meta); }catch(e){ console.warn('orig logEvent error', e); }
    status('記録: ' + rec.type + '（' + rec.timeISO + '）');
    return rec;
  };

  // ---------- bind "今を記録" (by id and by label) ----------
  function bindRecordNow(){
    const bind = el => { if(!el || el.__rec_v3) return; el.__rec_v3=true; el.addEventListener('click', ()=>{ window.logEvent('manual', {}); }); };
    const idBtn = document.getElementById('btnRecordNow'); if(idBtn) bind(idBtn);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('今を記録')>=0).forEach(bind);
  }

  // ---------- optional auto logging (uses existing checkbox/threshold/target if present) ----------
  (function(){
    const chk = document.getElementById('chkAutoSpaLog');
    const inpTh = document.getElementById('inpSpaLevelThresh');
    const targetSel = document.getElementById('selSpaLevelTarget');
    let last = 0;
    function tick(){
      if(!(chk&&chk.checked)) return;
      const th = parseFloat(inpTh?.value||'2.1');
      const t = (targetSel?.value||'C');
      const lv = getLevels();
      const cur = t==='A'?lv.A : t==='B'?lv.B : lv.C;
      const now = Date.now();
      if(Number.isFinite(cur) && cur>=th && now-last>10000){
        last = now;
        window.logEvent('level', { levelA: lv.A, levelB: lv.B, levelC: lv.C });
      }
    }
    setInterval(tick, 1000);
  })();

  // ---------- CSV export (single handler) ----------
  function exportCSV(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
    function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
    function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
    function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
    function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([ csvEscape(r.place??''), csvEscape(dt.date), csvEscape(dt.time),
                  csvEscape(fmtA(r.levelA)), csvEscape(fmtB(r.levelB)), csvEscape(fmtC(r.levelC)) ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    status('CSVを書き出しました（場所,日付,時間,ABC）');
  }
  function bindCSV(){
    const attach = el => { if(!el || el.__csv_v3) return; el.__csv_v3=true; el.addEventListener('click', exportCSV, {capture:false}); };
    const idBtn = document.getElementById('btnExportCSV'); if(idBtn) attach(idBtn);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0).forEach(attach);
  }

  function init(){ bindRecordNow(); bindCSV(); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>

<script>
(function(){
  if (window.__spa_singleclick_v4__) return; window.__spa_singleclick_v4__=true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }

  function exportCSVOnce(){
    // cooldown guard
    const now = Date.now();
    if (window.__spa_csv_cooldown && now - window.__spa_csv_cooldown < 800) return;
    window.__spa_csv_cooldown = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }
    const header = ['場所','日付','時間','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }
    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    status('CSVを書き出しました（場所,日付,時間,ABC）');
  }

  function cleanBind(el){
    if(!el) return;
    // Replace with a clean clone to drop existing listeners (prevents multi-download)
    const clone = el.cloneNode(true);
    // keep id and text as-is; replace in DOM
    el.replaceWith(clone);
    // Bind a single click handler; do not stop propagation; once:false (guard handles repeats)
    clone.addEventListener('click', exportCSVOnce, {capture:false});
    return clone;
  }

  function init(){
    let attached = 0;
    // 1) id-based
    const idBtn = document.getElementById('btnExportCSV');
    if(idBtn){ cleanBind(idBtn); attached++; }
    // 2) label-based
    const nodes = Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0);
    nodes.forEach(n => { cleanBind(n); attached++; });
    // 3) ensure at least one exists: if none, create a minimal fallback next to geoStatus
    if(attached===0){
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      cleanBind(fb);
    }
  }

  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>

<script>
(function(){
  // Add Lon/Lat to CSV and set default auto-target to A, keeping UI unchanged.
  if (window.__spa_latlon_v5__) return; window.__spa_latlon_v5__ = true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSVOnceV5(){
    // Unified single-click guard (works alongside existing one)
    const now = Date.now();
    if (window.__spa_csv_cooldown2 && now - window.__spa_csv_cooldown2 < 800) return;
    window.__spa_csv_cooldown2 = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    // Header with Lon/Lat
    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    status('CSVを書き出しました（場所,日付,時間,経度,緯度,ABC）');
  }

  function bind(){
    // Default auto target = A (set value on load; user can still change later)
    const sel = document.getElementById('selSpaLevelTarget');
    if (sel) sel.value = 'A';

    // Attach our CSV handler in the capture phase so it runs first.
    const buttons = new Set();
    const byId = document.getElementById('btnExportCSV'); if(byId) buttons.add(byId);
    Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .filter(n => (n.textContent||'').indexOf('イベントCSV')>=0)
      .forEach(n => buttons.add(n));
    buttons.forEach(el => {
      if (!el || el.__latlon_v5_bound) return;
      el.__latlon_v5_bound = true;
      el.addEventListener('click', function(ev){
        try{ exportCSVOnceV5(); }catch(e){ console.error(e); }
      }, {capture:true});
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bind); } else { bind(); }
})();
</script>

<script>
(function(){
  if (window.__spa_csv_v6__) return; window.__spa_csv_v6__=true;

  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSV_v6(){
    const now = Date.now();
    if (window.__spa_csv_cooldown_v6 && now - window.__spa_csv_cooldown_v6 < 800) return;
    window.__spa_csv_cooldown_v6 = now;

    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    status('CSVを書き出しました（場所,日付,時間,経度,緯度,ABC）');
  }

  function cleanBindOne(el, primary){
    const clone = el.cloneNode(true);
    el.replaceWith(clone);
    if (primary){
      clone.addEventListener('click', exportCSV_v6, {capture:false});
    } else {
      // Non-primary buttons just proxy to primary click for visual consistency
      clone.addEventListener('click', function(){ try{ primary.click(); }catch(_){} }, {capture:false});
    }
    return clone;
  }

  function init(){
    // 1) Default auto target = A
    const sel = document.getElementById('selSpaLevelTarget');
    if (sel) sel.value = 'A';

    // 2) Collect all CSV-like buttons
    const candidates = [];
    const idBtn = document.getElementById('btnExportCSV');
    if (idBtn) candidates.push(idBtn);
    document.querySelectorAll('button, a, [role="button"]').forEach(n => {
      const t = (n.textContent||'').trim();
      if (t.indexOf('イベントCSV')>=0) candidates.push(n);
    });

    // 3) Choose primary (prefer id button), clone to remove all old listeners, bind only our handler
    if (candidates.length===0){
      // Fallback: create one
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      cleanBindOne(fb, fb); // primary is itself
      return;
    }
    // Deduplicate nodes
    const uniq = Array.from(new Set(candidates));
    const primary = idBtn && uniq.includes(idBtn) ? idBtn : uniq[0];
    const primaryCloned = cleanBindOne(primary, true);

    // Rebind others to proxy the primary
    uniq.forEach(n => {
      if (n===primary) return;
      cleanBindOne(n, primaryCloned);
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>

<script>
(function(){
  if (window.__spa_csv_v7_dedup__) return; window.__spa_csv_v7_dedup__=true;

  // ---- Helpers (robust fallbacks) ----
  function nowJST(){
    const d = new Date();
    return d.toLocaleString('ja-JP', { timeZone:'Asia/Tokyo', year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit' });
  }
  function status(t){ const el=document.getElementById('geoStatus'); if(el) el.textContent=t; }
  function numText(el){ if(!el) return null; const t=(el.textContent||'').replace(/[^\d\.\-]/g,''); const v=parseFloat(t); return Number.isFinite(v)?v:null; }
  function getLevels(){
    try{ if (typeof window.getLatchedLevels==='function') return window.getLatchedLevels(); }catch(_){}
    return {
      A: numText(document.getElementById('kpiLevelA')),
      B: numText(document.getElementById('kpiLevelB')),
      C: numText(document.getElementById('kpiLevelC')),
    };
  }
  function readGPS(){
    const g = id => document.getElementById(id);
    const pf = v => { const x=parseFloat(v); return Number.isFinite(x)?x:null; };
    return {
      lat: pf(g('geoLat')?.value), lon: pf(g('geoLon')?.value),
      acc: pf(g('geoAcc')?.value), spd: pf(g('geoSpd')?.value), head: pf(g('geoHead')?.value),
    };
  }
  function placeEnabled(){ const c = document.getElementById('chkIncludePlace'); return (c==null) ? true : !!c.checked; }
  function attachLoc(){ const c = document.getElementById('chkAttachLoc'); return !!(c&&c.checked); }
  function placeName(){ return placeEnabled() ? ((document.getElementById('placeName')?.value)||'') : ''; }
  function memoText(){ return (document.getElementById('placeMemo')?.value)||''; }
  function loadEventLog(){ try{ const s=localStorage.getItem('spa_event_log'); return s? JSON.parse(s) : []; }catch(_){ return []; } }
  function saveEventLog(){ try{ localStorage.setItem('spa_event_log', JSON.stringify(window.eventLog||[])); }catch(_){ } }

  // ---- De-duplicating logEvent wrapper ----
  function eq(a,b){ return (a===b) || (Number.isFinite(a)&&Number.isFinite(b)&&Math.abs(a-b)<1e-9); }
  function sameRec(r1,r2){
    if(!r1||!r2) return false;
    return (r1.type===r2.type)
       && (r1.place===r2.place)
       && (r1.timeISO===r2.timeISO)
       && eq(r1.levelA, r2.levelA)
       && eq(r1.levelB, r2.levelB)
       && eq(r1.levelC, r2.levelC)
       && eq(r1.lon, r2.lon)
       && eq(r1.lat, r2.lat);
  }

  window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();
  const prevLogEvent = window.logEvent;

  window.logEvent = function(kind, meta={}){
    const beforeLen = Array.isArray(window.eventLog) ? window.eventLog.length : 0;
    let prevLast = beforeLen ? window.eventLog[beforeLen-1] : null;

    // Call original first (if any)
    let origResult = null;
    try{ if (typeof prevLogEvent==='function') origResult = prevLogEvent(kind, meta); }catch(_){}

    // Ensure eventLog array exists
    window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : loadEventLog();

    const afterLen = window.eventLog.length;
    if (afterLen > beforeLen){
      // A new record was added by original handler -> fill missing fields + dedup with previous
      let last = window.eventLog[afterLen-1];
      // Fill
      const lv = getLevels();
      if(!Number.isFinite(last.levelA)) last.levelA = Number.isFinite(lv.A)? lv.A : last.levelA;
      if(!Number.isFinite(last.levelB)) last.levelB = Number.isFinite(lv.B)? lv.B : last.levelB;
      if(!Number.isFinite(last.levelC)) last.levelC = Number.isFinite(lv.C)? lv.C : last.levelC;
      if(!('place' in last)) last.place = placeName();
      if(attachLoc()){
        const gps = readGPS();
        if(!Number.isFinite(last.lon)) last.lon = gps.lon;
        if(!Number.isFinite(last.lat)) last.lat = gps.lat;
      }
      if(!last.timeISO) last.timeISO = nowJST();
      // Dedup with second last
      if (beforeLen && sameRec(last, prevLast)){
        window.eventLog.splice(afterLen-1, 1); // remove duplicate
      }
      saveEventLog();
      return last;
    } else {
      // Original didn't push -> we push our own record
      const lv = getLevels();
      const gps = attachLoc()? readGPS() : {lat:null,lon:null,acc:null,spd:null,head:null};
      const rec = {
        timeISO: nowJST(),
        epoch: Date.now(),
        type: kind||'manual',
        levelA: Number.isFinite(meta.levelA) ? meta.levelA : (Number.isFinite(lv.A)? lv.A : null),
        levelB: Number.isFinite(meta.levelB) ? meta.levelB : (Number.isFinite(lv.B)? lv.B : null),
        levelC: Number.isFinite(meta.levelC) ? meta.levelC : (Number.isFinite(lv.C)? lv.C : null),
        spa: Number.isFinite(meta.spa) ? meta.spa : null,
        p: Number.isFinite(meta.p) ? meta.p : null,
        ...gps,
        place: placeName(),
        note: (meta.note ?? memoText()) + ''
      };
      rec.level = Number.isFinite(meta.level) ? meta.level : (Number.isFinite(rec.levelC)? rec.levelC : (Number.isFinite(rec.levelB)? rec.levelB : rec.levelA));

      if (!sameRec(rec, prevLast)){
        window.eventLog.push(rec);
        saveEventLog();
        status('記録: ' + rec.type + '（' + rec.timeISO + '）');
      }
      return rec;
    }
  };

  // ---- CSV export: unique rows only (lon/lat included) ----
  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\r\n]/.test(t) ? '"' + t.replace(/"/g,'""') + '"' : t; }
  function splitDateTime(jst){ const m=String(jst).match(/^(\d{4}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})$/); return m?{date:m[1],time:m[2]}:{date:String(jst),time:''}; }
  function fmtA(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtB(v){ return Number.isFinite(v) ? v.toFixed(1) : ''; }
  function fmtC(v){ return Number.isFinite(v) ? v.toFixed(2) : ''; }
  function fmtLon(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }
  function fmtLat(v){ return Number.isFinite(v) ? v.toFixed(6) : ''; }

  function exportCSV_v7_unique(){
    const log = Array.isArray(window.eventLog) ? window.eventLog : [];
    if(!log.length){ status('CSV対象のイベントがありません'); return; }

    const header = ['場所','日付','時間','経度','緯度','SPAレベルA','SPAレベルB','SPAレベルC'];
    const rows = [header.join(',')];

    const seen = new Set();
    for(const r of log){
      const dt = splitDateTime(r.timeISO ?? '');
      const key = [
        r.place ?? '', dt.date, dt.time,
        Number.isFinite(r.lon)? r.lon.toFixed(6):'',
        Number.isFinite(r.lat)? r.lat.toFixed(6):'',
        Number.isFinite(r.levelA)? r.levelA.toFixed(1):'',
        Number.isFinite(r.levelB)? r.levelB.toFixed(1):'',
        Number.isFinite(r.levelC)? r.levelC.toFixed(2):'',
      ].join('|');
      if (seen.has(key)) continue;
      seen.add(key);
      rows.push([
        csvEscape(r.place ?? ''),
        csvEscape(dt.date),
        csvEscape(dt.time),
        csvEscape(fmtLon(r.lon)),
        csvEscape(fmtLat(r.lat)),
        csvEscape(fmtA(r.levelA)),
        csvEscape(fmtB(r.levelB)),
        csvEscape(fmtC(r.levelC)),
      ].join(','));
    }

    const bom = new Uint8Array([0xEF,0xBB,0xBF]);
    const blob = new Blob([bom, rows.join('\r\n')], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'spa_events_place_date_time_lonlat_ABC.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    status('CSVを書き出しました（重複排除）');
  }

  // ---- Rebind CSV button to our unique exporter (single click) ----
  function bindUniqueCSV(){
    const candidates = [];
    const idBtn = document.getElementById('btnExportCSV');
    if (idBtn) candidates.push(idBtn);
    document.querySelectorAll('button, a, [role="button"]').forEach(n => {
      const t = (n.textContent||'').trim();
      if (t.indexOf('イベントCSV')>=0) candidates.push(n);
    });
    const uniq = Array.from(new Set(candidates));
    if (uniq.length===0){
      const fb = document.createElement('button');
      fb.textContent = 'イベントCSV';
      const anchor = document.getElementById('geoStatus') || document.body;
      anchor.parentNode.insertBefore(fb, anchor.nextSibling);
      uniq.push(fb);
    }
    // Choose primary
    const primary = idBtn && uniq.includes(idBtn) ? idBtn : uniq[0];
    // Clone + bind (remove old listeners)
    const primClone = primary.cloneNode(true);
    primary.replaceWith(primClone);
    primClone.addEventListener('click', (ev)=>{
      const now = Date.now();
      if (window.__spa_csv_cooldown_v7 && now - window.__spa_csv_cooldown_v7 < 800) return;
      window.__spa_csv_cooldown_v7 = now;
      exportCSV_v7_unique();
    }, {capture:false});

    // Other buttons proxy to primary
    uniq.forEach(n => {
      if (n===primary) return;
      const c = n.cloneNode(true);
      n.replaceWith(c);
      c.addEventListener('click', ()=>{ primClone.click(); }, {capture:false});
    });
  }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bindUniqueCSV); } else { bindUniqueCSV(); }
})();
</script>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('./sw.js').catch(function(e){ console.log('SW reg failed', e); });
  });
}
</script>

</body>
</html>
